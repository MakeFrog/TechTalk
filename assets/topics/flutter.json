[
  {
    "id": "flutter-1",
    "question": "StatelessWidget과 StatefulWidget의 차이에 대해 설명해주세요",
    "answers": [
      "StatelessWidget은 한 번 생성된 후 변하지 않는 정적인 위젯이며, StatefulWidget은 내부 상태를 가지고 있어 화면이 업데이트되거나 사용자 상호 작용에 따라 상태가 변경될 수 있는 동적인 위젯입니다."
    ]
  },
  {
    "id": "flutter-2",
    "question": "BuildContext에 대해 설명해주세요",
    "answers": [
      "BuildContext는 Flutter 프레임워크에서 위젯 트리를 탐색하고 위젯 간에 정보를 전달하는 데 사용되는 객체입니다. 현재 위젯의 위치와 상태에 대한 정보를 포함하고 있습니다.",
      "일반적으로 위젯의 빌드 메서드 내에서 사용되며, 위젯의 위치, 테마, 크기 및 다른 위젯과의 관계 등을 결정하는 데 중요한 역할을 합니다."
    ]
  },
  {
    "id": "flutter-3",
    "question": "Future와 Stream의 공통점과 차이점에 대해 설명해주세요",
    "answers": [
      "Future와 Stream의 공통점은 비동기적인 작업을 처리할 수 있다는 점입니다. 둘 다 비동기적인 결과를 처리하고, 비동기 작업을 수행하는 데 유용합니다. 그러나 차이점은 Future는 단일 값 또는 오류를 반환하는 반면, Stream은 연속된 값의 흐름을 반환한다는 것입니다.",
      "Future는 한 번의 작업 후 결과를 반환하고 종료되지만, Stream은 여러 값 또는 이벤트를 순차적으로 전달하며, 종료되지 않고 계속 값을 생성할 수 있습니다."
    ]
  },
  {
    "id": "flutter-4",
    "question": "StatefulWidget이 가지는 State의 생명주기를 상세하게 설명해 주세요.",
    "answers": [
      "StatefulWidget이 가지는 State의 생명주기는 다음과 같습니다.",
      "- initState(): State 객체가 생성되고 위젯 트리에 추가될 때 호출됩니다. 이 메서드에서는 초기화 작업을 수행하거나 한 번만 수행되어야 하는 작업을 처리합니다.",
      "- didChangeDependencies(): State 객체가 의존성에 대한 변경을 감지했을 때 호출됩니다. 예를 들어, 부모 위젯이나 위젯 트리 내에서 의존하는 객체가 변경되었을 때 호출됩니다.",
      "- didUpdateWidget(oldWidget): State 객체가 새로운 위젯 인스턴스와 연결되었을 때 호출됩니다. 이 메서드에서는 이전 위젯과 현재 위젯 간의 차이를 처리할 수 있습니다.",
      "- build(BuildContext context): 위젯을 다시 그릴 때 호출됩니다. 이 메서드에서는 화면을 구성하는 위젯을 반환합니다.",
      "- setState(VoidCallback fn): 상태가 업데이트되었음을 프레임워크에 알리고, 위젯을 다시 그리도록 스케줄링합니다.",
      "- dispose(): State 객체가 제거되기 전에 호출됩니다. 이 메서드에서는 리소스를 해제하거나 구독을 취소하는 등의 정리 작업을 수행합니다."
    ]
  },
  {
    "id": "flutter-5",
    "question": "setState을 사용했을 때 어떤 일이 일어나는지 설명해 주세요",
    "answers": [
      "setState()를 호출하면 Flutter 프레임워크는 해당 State의 상태를 업데이트하고, 연결된 StatefulWidget의 build() 메서드를 호출하여 화면을 다시 그립니다. 이를 통해 상태 변화가 반영된 새로운 UI가 사용자에게 보여집니다."
    ]
  },
  {
    "id": "flutter-6",
    "question": "Flutter에서 Key의 역할은 무엇인가요?",
    "answers": [
      "Key는 Flutter에서 위젯의 고유 식별자로 사용됩니다. Key를 사용하면 위젯이 재사용되거나 이동할 때 Flutter가 정확히 어떤 위젯을 업데이트해야 하는지 판단할 수 있습니다."
    ]
  },
  {
    "id": "flutter-7",
    "question": "위젯이 빌드되는 과정을 주요 3가지의 위젯 트리를 통해 설명해주세요",
    "answers": [
      "Flutter 애플리케이션은 위젯 트리에서 시작하여 엘리먼트 트리를 거쳐 렌더 트리로 변환되며, 최종적으로 화면에 표시됩니다.",
      "Widget Tree: 위젯 트리는 Flutter 애플리케이션의 UI를 계층 구조로 표현한 것입니다. 이는 위젯들이 부모-자식 관계로 구성되어 있으며, 화면에 표시되는 모든 위젯이 이에 속합니다.",
      "Element Tree: 엘리먼트 트리는 위젯 트리의 구현체로, Flutter 엔진이 위젯 트리를 관리하고 조작하기 위해 사용됩니다. 엘리먼트는 위젯과 동일한 계층 구조를 가지며, 각각의 위젯에 대한 불변성 정보를 포함합니다.",
      "Render Tree: 렌더 트리는 실제 화면에 렌더링되는 위젯의 표현입니다. 위젯 트리의 각 위젯에 해당하는 렌더 객체들이 모여서 구성됩니다. Flutter 엔진은 렌더 트리를 사용하여 화면을 그리고, 위젯의 크기, 위치 및 모양을 결정합니다."
    ]
  },
  {
    "id": "flutter-8",
    "question": "CachedNetworkImage 패키지를 사용하여 이미지를 캐싱할 때, 이미지가 캐싱되는 기준을 어떻게 판별할 수 있나요?",
    "answers": [
      "Flutter의 CachedNetworkImage는 이미지를 캐싱하기 위해 여러 가지 기준을 사용합니다. 기본적으로 URL을 기반으로 이미지를 캐싱하며, 같은 URL의 이미지는 동일한 이미지로 간주됩니다. 이를 통해 동일한 이미지가 여러 번 로드될 때 캐싱된 이미지가 다시 사용됩니다."
    ]
  },
  {
    "id": "flutter-9",
    "question": "isolate에 대한 개념을 설명해주세요",
    "answers": [
      "isolate는 독립적인 작업 단위로, 자체적인 메모리 공간을 가지고 병렬 처리 및 비동기 작업을 수행하는 기능입니다. 각 isolate는 자체적으로 실행되는 코드를 가지며, 메모리를 공유하지 않고 통신을 위해 메시지 전달을 사용함 이를 통해 플러터 애플리케이션에서 병렬 작업을 처리하고, 응답성을 향상시키며, 긴 작업을 분리하여 앱의 성능을 개선할 수 있습니다."
    ]
  },
  {
    "id": "flutter-10",
    "question": "ListView와 ListView.builder의 차이점에 대해 설명해주세요",
    "answers": [
      "ListView는 모든 아이템을 한 번에 생성하여 메모리를 소비하고, 화면에 보여지지 않는 아이템도 렌더링합니다. 반면에 ListView.builder는 화면에 보이는 영역에만 아이템을 생성하여 메모리를 절약하고, 스크롤되는 동안 필요한 아이템만 생성하여 효율적인 성능을 제공합니다."
    ]
  },
  {
    "id": "flutter-11",
    "question": "mixin에 대해서 설명해주세요",
    "answers": [
      "Mixin은 다중 상속을 지원하지 않는 언어에서 코드 재사용을 촉진하기 위한 방법 중 하나입니다. 이는 클래스가 다른 클래스의 특성을 가져올 수 있게 해주는 재사용 가능한 코드 조각입니다.",
      "일반적으로 클래스에 구현할 수 있는 메서드나 속성을 포함하는데 사용됩니다. mixin은 해당 클래스에 구현되는 특정 동작이나 특성을 정의하고 다른 클래스에서 필요에 따라 가져와 사용할 수 있도록 합니다. 따라서 코드를 재사용하고 간결하게 유지할 수 있습니다."
    ]
  },
  {
    "id": "flutter-12",
    "question": "Inherited Widget에 대해 설명해주세요",
    "answers": [
      "InheritedWidget은 상위 위젯에서 하위 위젯으로 데이터를 전달하는 Flutter의 위젯입니다. 이를 통해 앱 전체에서 데이터 공유와 업데이트가 가능해지며, 효율적인 상태 관리가 가능합니다"
    ]
  },
  {
    "id": "flutter-13",
    "question": "Expanded 위젯에 대한 개념과 언제 사용하는지 설명해주세요",
    "answers": [
      "Expanded 위젯은 자식 위젯이 확장되어 부모 위젯의 사용 가능한 모든 공간을 차지하도록 하는 것이 맞습니다. 제가 그 내용을 올바르게 설명하지 않았습니다. 이를 정정해주셔서 감사합니다."
    ]
  },
  {
    "id": "flutter-14",
    "question": "Expanded 위젯에 대한 개념과 언제 사용하는지 설명해주세요",
    "answers": [
      "Expanded 위젯은 자식 위젯이 확장되어 부모 위젯의 사용 가능한 모든 공간을 차지하도록 구성할 때 사용합니다."
    ]
  },
  {
    "id": "flutter-15",
    "question": "Dart에서 제공하는 컬렉션의 종류와 각각의 개념을 설명해주실 수 있나요?",
    "answers": [
      "Dart에서 가장 일반적으로 사용되는 컬렉션 List, Set, Map입니다",
      "List는 순서가 있는 데이터의 목록입니다. 이는 데이터를 인덱스로 접근할 수 있다는 것을 의미합니다. List에는 중복된 요소가 포함될 수 있습니다. 이러한 특성은 데이터를 순차적으로 저장하고 관리하는 데 유용합니다",
      "Set은 순서가 없는 고유한 요소들의 모음입니다. Set은 중복된 요소를 허용하지 않습니다. 따라서 중복을 제거하고 고유한 값만을 관리하고자 할 때 유용합니다.",
      " Map은 키-값 쌍의 컬렉션입니다. 각 요소는 고유한 키와 연결된 값으로 구성됩니다. Map은 키를 기반으로 값을 검색하고 관리하는 데 사용됩니다. 이는 데이터를 검색 및 조작하는 데 있어 효율적인 방법을 제공합니다."
    ]
  },
  {
    "id": "flutter-16",
    "question": "Flutter에서 사용되는 Sliver에 대한 개념과 언제 사용하는지 설명해주세요.",
    "answers": [
      "Sliver는 스크롤 영역의 일부분으로 Flutter에서 스크롤되는 모든것이 Sliver입니다",
      "이는 스크롤 가능한 리스트와 그리드와 같은 위젯들을 만들 때 매우 유용합니다.",
      "Sliver는 일반적으로 CustomScrollView 내에서 사용됩니다. CustomScrollView는 여러 Sliver 위젯을 함께 조합하여 스크롤 동작을 제어할 수 있는 위젯입니다. 이러한 Sliver들은 각각이 스크롤되는 방식에 대해 세밀한 제어를 제공합니다."
    ]
  },
  {
    "id": "flutter-17",
    "question": "Flutter Dio 패키지에 대한 개념과 사용할 수 있을 때 이점을 설명해주세요.",
    "answers": [
      "Dio를 사용하는 주요 이점 중 하나는 강력한 기능과 다양한 옵션을 제공한다는 것입니다. 이 패키지는 HTTP 요청을 보내고 응답을 받는 데 필요한 모든 기능을 제공합니다. 예를 들어, Dio는 다양한 HTTP 메서드(GET, POST, PUT, DELETE 등)를 지원하고, 인터셉터를 통해 요청과 응답을 수정할 수 있는 기능을 제공합니다.",
      "또한 Dio는 편리한 기능들을 제공하여 네트워킹 코드를 간결하게 작성할 수 있도록 도와줍니다. 예를 들어, Dio는 인터셉터를 사용하여 요청과 응답을 로깅하거나 인증 토큰을 추가하는 등의 작업을 수행할 수 있습니다.",
      "마지막으로, Dio는 Flutter 앱의 안정성을 높이고 에러 처리를 간편하게 할 수 있는 기능을 제공합니다. 예외 처리를 통해 네트워킹과 관련된 문제를 적절히 처리할 수 있고, 네트워킹에 관련된 다양한 오류들을 쉽게 처리할 수 있습니다."
    ]
  },
  {
    "id": "flutter-18",
    "question": "Scaffold.of(context) 코드가 어떻게 작동하는지 BuildContext의 개념을 사용하여 설명해주세요.",
    "answers": [
      "BuildContext는 Flutter에서 위젯 트리의 위치와 속성에 대한 정보를 제공하는 객체입니다. Scaffold.of(context)는 이 BuildContext를 활용하여 현재 위젯 트리에서 가장 가까운 Scaffold 위젯을 찾아내는 데 사용됩니다.",
      "BuildContext를 사용하여 Scaffold.of(context)는 위에서 아래로 현재 위젯의 부모와 자식을 탐색합니다. 이 과정에서 가장 가까운 Scaffold 위젯을 찾으면 해당 Scaffold의 인스턴스를 반환합니다.",
      "예를 들어, Scaffold.of(context)가 호출된 위젯이 Scaffold의 자식 위젯이라면, BuildContext를 통해 해당 Scaffold 위젯을 찾을 수 있습니다. 그러나 만약 바로 아래 단계에 Scaffold가 없다면, 부모 위젯으로 올라가면서 계속해서 탐색을 진행합니다.",
      "이러한 방식으로 Scaffold.of(context)는 현재 위젯 트리에서 가장 가까운 Scaffold 위젯에 대한 참조를 얻을 수 있습니다. 그리고 이를 통해 해당 Scaffold에 대한 작업을 수행할 수 있게 됩니다. 하지만 주의할 점은 Scaffold.of(context)를 사용할 때, 해당 Scaffold가 실제로 존재하는지 항상 확인해야 한다는 것입니다."
    ]
  },
  {
    "id": "flutter-20",
    "question": "해당 코드에서 출력되는 알파벳 대문자를 순서대로 나열해주세요\nvoid main() {\n  print('A');\n  Future(() {\n    print('B');\n    Future(() => print('C'));\n    Future.microtask(() => print('D'));\n    Future(() => print('E'));\n    print('F');\n  });\n  Future.microtask(() => print('G'));\n  print('H');\n}\n",
    "answers": [
      "A -> H -> G -> B -> F -> D -> C -> E 순서로 실행됩니다",
      "먼저, 기적인 작업으로 main() 함수가 시작되면서 A가 출력됩니다. 이어서 H가 출력되는데, 이는 동기적인 작업의 결과로서 Future 생성자 밖에서 가장 먼저 실행되기 때문입니다.",
      "그 다음, 비동기적인 작업인 Future와 Future.microtask에 의해 정의된 작업들이 실행됩니다. Future 내부의 작업은 B부터 시작하여 F까지 실행되며, Future.microtask 내부의 작업은 G와 D가 실행됩니다. 이때 D가 C보다 먼저 출력됩니다.",
      "마지막으로 C와 E가 각각의 Future 내부에서 출력됩니다."
    ]
  },
  {
    "id": "flutter-21",
    "question": "var, final, const 키워드를 사용하여 위와 같이 list1, list2, list3를 선언하였습니다. 해당 키워드의 차이점은 무엇이고 마지막 줄이 컴파일 되는지 설명해 보세요.\nvar list1 = ['I', 'Love', 'Flutter'];\nfinal list2 = list1;\nconst list3 = list1; // 해당 라인이 컴파일 되나요?",
    "answers": [
      "var: 변수를 선언하고 초기화할 때 사용됩니다. 컴파일러는 변수의 타입을 초기화 값에 따라 유추합니다. 따라서 변수의 타입은 컴파일 시간에 결정되며, 나중에 변경될 수 있습니다.",
      "final: 변수를 선언하고 한 번만 초기화할 수 있습니다. 초기화된 이후에는 변경할 수 없습니다. 이는 런타임에 값이 결정되지만 변경되지 않음을 보장합니다.",
      "const: 변수를 선언하고 컴파일 시간에 상수로 평가됩니다. 즉, 변수의 값이 컴파일 시간에 결정되며, 이후에 변경할 수 없습니다.",
      "list3는 const 키워드로 선언되었으며, 초기화 값으로 list1을 사용했습니다. 그러나 list1은 런타임에 결정되는 변수이기 때문에 컴파일 시간에는 알 수 없는 값입니다. 따라서 list3는 컴파일 시간에 상수로 평가되지 못하므로 이 코드는 컴파일 시간에 오류를 발생시킬 것입니다."
    ]
  },
  {
    "id": "flutter-22",
    "question": "상태관리 패키지를 사용하여 얻는 이점에 대해 설명해주세요.",
    "answers": [
      "의존성 주입(Dependency Injection)과 UI 동기화는 상태 관리 패키지를 사용함으로써 얻을 수 있는 중요한 장점 중 일부입니다.",
      "상위 위젯에서 하위 위젯 트리에 데이터를 주입(Dependency Injection)하여 데이터를 일일이 넘겨주는 작업을 줄이고, 코드의 가독성과 유지보수성을 향상시킵니다. 이는 외부 종속성을 관리하고 앱의 다양한 부분에서 동일한 상태를 공유하는 데에 도움이 됩니다. 또한, 상위에서 주입된 데이터를 하위 위젯에서 수정하더라도 해당 데이터는 전체 앱에 반영되므로 일관된 상태 관리가 가능해집니다.",
      "UI 동기화는 상태 변화를 감지하고 UI를 업데이트하여 사용자에게 실시간으로 반영함으로써 사용자 경험을 향상시킵니다. 상태 관리 패키지는 UI와 상태를 동기화하여 UI가 항상 최신 상태를 유지할 수 있도록 지원합니다. 이는 사용자에게 즉각적인 피드백을 제공하고 앱의 반응성을 향상시킵니다.",
      "상태 관리 패키지를 사용하여 의존성 주입과 UI 동기화를 활용함으로써 코드의 효율성을 높이고 사용자 경험을 향상시킬 수 있습니다."
    ]
  }
]