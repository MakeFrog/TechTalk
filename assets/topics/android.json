[
  {
    "id": "android-1",
    "question": "안드로이드의 생명주기(Life Cycle)란 무엇인가요?",
    "answers": [
      "안드로이드 앱은 사용자의 액션에 따라서 수명주기를 가집니다. 앱의 생명주기는 다음과 같은 상태로 구성됩니다.\n·비활성화 상태\n·활성화 상태\n·일시정지 상태\n·중지 상태\n·종료 상태"
    ]
  },

  {
    "id": "android-2",
    "question": "안드로이드에서 Activity와 Fragment의 차이점은 무엇인가요?",
    "answers": [
      "Activity는 사용자 인터페이스(UI)를 가진 하나의 화면입니다.",
      "Fragment는 하나의 Activity 내에서 재사용 가능한 UI 조각입니다.",
      "여러 개의 Fragment를 하나의 Activity에 추가하여 모바일 앱의 멀티탭, 뷰페이저 등을 구현할 수 있습니다."
    ]
  },
  {
    "id": "android-3",
    "question": "안드로이드에서 Intent란 무엇인가요?",
    "answers": [
      "안드로이드에서 Intent는 다른 컴포넌트(Activity, Service, Broadcast Receiver)로 작업 요청을 보내는 메시지 객체입니다.",
      "Intent는 작업을 수행하는 데 필요한 데이터와 대상 컴포넌트 정보를 포함합니다.",
      "암시적(Intent.ACTION_VIEW) 또는 명시적(Intent(ComponentName))으로 사용할 수 있습니다."
    ]
  },
  {
    "id": "android-4",
    "question": "안드로이드에서 Service란 무엇인가요?",
    "answers": [
      "안드로이드에서 Service는 백그라운드에서 실행되는 앱 구성 요소입니다.",
      "Service는 사용자 인터페이스(UI)를 제공하지 않으며, 오랫동안 실행될 수 있습니다.",
      "예를 들어, 음악을 재생하는 앱에서 노래를 재생하는 기능을 Service로 구현할 수 있습니다."
    ]
  },
  {
    "id": "android-5",
    "question": "안드로이드에서 BroadcastReceiver란 무엇인가요",
    "answers": [
      "안드로이드에서 BroadcastReceiver는 앱에서 발생하는 이벤트를 수신하는 앱 구성 요소입니다.",
      "BroadcastReceiver는 등록된 이벤트가 발생할 때마다 실행됩니다.",
      "예를 들어, 배터리가 부족해지면 BroadcastReceiver를 사용하여 알림을 받을 수 있습니다."
    ]
  },
  {
    "id": "android-6",
    "question": "안드로이드에서 AsyncTask란 무엇인가요?",
    "answers": [
      "안드로이드에서 AsyncTask는 비동기적인 작업을 수행하기 위한 클래스입니다.",
      "AsyncTask는 메인 스레드에서는 실행되지 않으며, 백그라운드 스레드에서 실행됩니다.",
      "AsyncTask는 doInBackground() 메서드에서 백그라운드 작업을 수행하고, 결과 값을 onPostExecute() 메서드에서 반환합니다."
    ]
  },

  {
    "id": "android-7",
    "question": "안드로이드에서 Retrofit이란 무엇인가요?",
    "answers": [
      "안드로이드에서 Retrofit은 RESTful API를 호출하는 라이브러리입니다.",
      "Retrofit은 OkHttp 라이브러리와 함께 사용되며, JSON 형식으로 데이터를 주고받을 수 있습니다.",
      "Retrofit은 인터페이스를 사용하여 API 호출을 정의하고, Retrofit 라이브러리가 자동으로 구현합니다."
    ]
  },
  {
    "id": "android-8",
    "question": "안드로이드에서 Room이란 무엇인가요?",
    "answers": [
      "안드로이드에서 Room은 SQLite 데이터베이스를 사용하기 쉽게 만든 라이브러리입니다.",
      "Room은 ORM(Object-Relational Mapping) 패턴을 사용하여 데이터베이스 작업을 추상화합니다.",
      "Room은 데이터베이스 쿼리를 컴파일하고, SQLite 데이터베이스에 대한 코드를 생성하여 작성을 용이하게 합니다."
    ]
  },
  {
    "id": "android-9",
    "question": "안드로이드에서 MVVM 패턴이란 무엇인가요?",
    "answers": [
      "안드로이드에서 MVVM(Model-View-ViewModel) 패턴은 사용자 인터페이스(UI)를 표현하는 뷰(View)와 데이터를 처리하는 모델(Model) 사이에 뷰 모델(ViewModel)을 두는 패턴입니다.",
      "ViewModel은 뷰와 모델 간의 의존성을 없애기 위해 사용됩니다.",
      "MVVM 패턴은 데이터와 UI를 분리하고, 테스트하기 쉬운 코드를 작성할 수 있습니다."
    ]
  },
  {
    "id": "android-10",
    "question": "안드로이드에서 ProGuard란 무엇인가요?",
    "answers": [
      "안드로이드에서 ProGuard는 코드 난독화, 최적화, 제거를 수행하는 도구입니다.",
      "ProGuard를 사용하면 앱의 크기를 줄이고, 보안을 강화할 수 있습니다.",
      "ProGuard는 안드로이드 스튜디오에서 쉽게 사용할 수 있으며, 프로젝트의 build.gradle 파일에 설정할 수 있습니다."
    ]
  },
  {
    "id": "android-11",
    "question": "lateinit과 lazy의 차이점은 무엇인가요?",
    "answers": [
      "lateinit과 lazy는 모두 초기화를 지연시켜주는 용도로 사용됩니다.",
      "lateinit은 var 프로퍼티에서만 사용 가능하며, 초기화를 변경할 수 있습니다.",
      "lateinit은 널 값을 통한 초기화를 할 수 없으며, 원시 타입에는 사용할 수 없습니다.",
      "lazy는 val 프로퍼티에서만 사용 가능하며, 한 번 초기화되면 값 변경이 불가능합니다.",
      "lazy는 호출 시점에 초기화됩니다."
    ]
  },
  {
    "id": "android-12",
    "question": "Context란 무엇인가요?",
    "answers": [
      "Context는 애플리케이션의 현재 상태를 나타내며, 액티비티와 애플리케이션의 정보를 얻기 위해 사용할 수 있습니다."
    ]
  },
  {
    "id": "android-13",
    "question": "인터페이스와 추상 클래스의 차이는 무엇인가요?",
    "answers": [
      "인터페이스와 추상 클래스는 모두 구현부분이 없는 추상적인 형태의 클래스로, 객체를 직접적으로 생성할 수 없습니다.",
      "둘 다 하나 이상의 추상 메서드나 프로퍼티를 가져 상속받았을 시 반드시 오버라이드 해야 합니다.",
      "차이점은 추상 클래스는 생성자를 가질 수 있지만, 인터페이스는 생성자를 가질 수 없습니다. 또한, 추상 클래스는 클래스의 특징과 인터페이스의 특징을 모두 가지고 있습니다.",
      "인터페이스는 다중 상속이 가능하지만 추상 클래스는 다중 상속이 불가능합니다."
    ]
  },
  {
    "id": "android-14",
    "question": "블로킹과 논블로킹의 차이는 무엇인가요?",
    "answers": [
      "블로킹은 A 함수에서 B 함수를 호출했을 때 코드의 제어권을 넘겨주어 A 함수는 코드 실행을 멈추고 B 함수가 실행됩니다. 그리고 B 함수가 끝났을 때 제어권을 돌려받아 A 함수 코드를 실행하는 것입니다. 논블로킹은 A 함수에서 B 함수가 호출되어도 제어권을 그대로 유지하면서 자신이 하던 작업을 계속하는 것을 의미합니다."
    ]
  },
  {
    "id": "android-15",
    "question": "리스트뷰와 리사이클러뷰의 차이는 무엇인가요?",
    "answers": [
      "리스트뷰는 아이템을 생성할 때 각각 모두 바인딩 해 주는 것이고, 리사이클러뷰는 ViewHolder를 강제하여 아이템을 한 번 바인딩한 후에는 재활용하여 사용합니다."
    ]
  },
  {
    "id": "android-16",
    "question": "리사이클러뷰의 어댑터란 무엇인가요?",
    "answers": [
      "리사이클러뷰의 어댑터는 리사이클러뷰에 표시될 아이템 뷰를 생성하는 역할을 합니다."
    ]
  },
  {
    "id": "android-17",
    "question": "List, Set, Map의 차이는 무엇인가요?",
    "answers": [
      "List는 순차적으로 요소가 저장되며 중복을 허용합니다. Set은 순서가 없는 요소들의 집합이며 중복을 허용하지 않습니다. Map은 key와 value로 이루어진 쌍(pair)의 집합이며, key는 중복을 허용하지 않습니다."
    ]
  },
  {
    "id": "android-18",
    "question": "오버로딩과 오버라이딩의 차이는 무엇인가요?",
    "answers": [
      "오버로딩은 같은 이름의 메소드가 2개 이상 존재하여 서로 다른 타입의 파라미터를 가지게 하는 것을 의미합니다. 오버라이딩은 상위 클래스에서 상속받은 메소드를 하위 클래스에서 재정의하여 사용하는 것을 의미합니다."
    ]
  },
  {
    "id": "android-19",
    "question": "스레드(Thread), 루퍼(Looper), 핸들러(Handler)의 역할에 대해 설명해주세요.",
    "answers": [
      "스레드는 하나의 독립적인 실행 흐름을 나타냅니다. 루퍼는 스레드에서 무한히 돌면서 메시지 큐에 message나 runnable이 들어오면 차례대로(선입선출) 핸들러에 전달합니다. 루퍼는 메인 스레드에는 자동 생성되지만 다른 새로 만든 스레드에는 자동 생성되지 않습니다. 핸들러는 메시지 큐로부터 받은 메시지나 런어블을 처리하거나 다른 스레드로부터 받은 message를 메시지 큐에 넣습니다."
    ]
  },
  {
    "id": "android-20",
    "question": "ViewHolder 패턴은 무엇인가요?",
    "answers": [
      "ViewHolder 패턴은 각 뷰의 객체를 ViewHolder에 보관하여, 뷰의 내용을 업데이트하기 위한 findViewById 메소드 호출을 줄여서 효과적으로 퍼포먼스를 개선할 수 있는 패턴입니다."
    ]
  },
  {
    "id": "android-21",
    "question": "Task란 무엇인가요?",
    "answers": [
      "Task는 액티비티의 묶음이며, 액티비티를 스택 형태로 관리합니다."
    ]
  },
  {
    "id": "android-22",
    "question": "dp와 sp의 차이는 무엇인가요?",
    "answers": [
      "위젯 크기나 여백 등의 레이아웃 크기를 지정할 때에는 dp를 사용하고, 텍스트 크기를 지정할 때에는 sp를 사용합니다."
    ]
  },
  {
    "id": "android-23",
    "question": "액티비티가 다시 재생성되어질 때는 언제인가요?",
    "answers": [
      "액티비티가 다시 재생성되는 시점은 다음과 같습니다.\n·화면이 회전하는 경우\n·다중 윈도우 모드에서 앱이 다시 크기를 조정하는 경우\n·앱의 리소스가 변경되어 구성이 변경되는 경우(예: 언어 변경, 테마 변경 등)\n·시스템이 액티비티를 강제로 종료하고 다시 시작해야 하는 경우(예: 메모리 부족 등)"
    ]
  },
  {
    "id": "android-24",
    "question": "동시성(병행성)과 병렬성의 차이는 무엇인가요?",
    "answers": [
      "동시성은 2개 이상의 작업을 교차하여 진행해 동시에 진행하는 것처럼 보이는 것을 의미합니다. 병렬성은 실제로 2개의 작업을 동시에 진행하는 것을 의미합니다."
    ]
  },
  {
    "id": "android-25",
    "question": "접근 제어자의 종류와 각 접근제어자에 대한 설명을 해주세요",
    "answers": [
      "접근 제어자를 사용하여 클래스의 멤버(필드, 메서드)의 접근 범위를 명확하게 지정할 수 있으며, 정보 은닉과 캡슐화를 통해 안정성과 유지보수성을 향상시킬 수 있습니다.",
      "주요한 접근 제어자와 각각의 설명은 다음과 같습니다.\n·public: 이 접근 제어자는 어떤 클래스든 접근할 수 있도록 합니다. 즉, 해당 멤버에 대한 외부 접근이 허용됩니다.\n·protected: 이 접근 제어자는 동일한 패키지 내의 클래스와 해당 클래스를 상속한 하위 클래스에서만 접근할 수 있습니다.\n·default (package-private): 접근 제어자를 명시적으로 지정하지 않은 경우, 디폴트 접근 제어자가 적용됩니다. 이는 동일한 패키지 내의 클래스들에게만 접근을 허용합니다.\n·private: 이 접근 제어자는 해당 멤버에 대한 접근을 해당 클래스 내부에서만 허용합니다. 즉, 외부 클래스나 상속 관계의 하위 클래스에서는 접근할 수 없습니다."
    ]
  },
  {
    "id": "android-26",
    "question": "AAPT란 무엇인가요?",
    "answers": [
      "AAPT는 Android Asset Packaging Tool의 약어입니다. 이 도구는 개발자에게 생성, 추출 및 보기를 포함하는 zip 호환 아카이브를 처리할 수 있는 기능을 제공합니다"
    ]
  },
  {
    "id": "android-27",
    "question": "ActivityCreator의 용도는 무엇입니까",
    "answers": [
      "ActivityCreator는 새로운 Android 프로젝트 생성을 위한 첫 번째 단계입니다. Android IDE 내에서 코드를 작성하는 데 필요한 새로운 파일 시스템 구조를 만드는 데 사용되는 쉘 스크립트로 구성됩니다."
    ]
  },
  {
    "id": "android-28",
    "question": "컨테이너에 대해 설명해주세요",
    "answers": [
      "이름 자체에서 알 수 있듯이 컨테이너는 필요한 특정 항목과 원하는 특정 배열에 따라 개체와 위젯을 함께 보관합니다. 예를 들어 컨테이너에는 레이블, 필드, 버튼 또는 하위 컨테이너도 포함될 수 있습니다."
    ]
  },
  {
    "id": "android-29",
    "question": "String과 StringBuffer의 차이점은 무엇인가요?",
    "answers": [
      "String은 불변성을 가지고 있어 문자열을 수정할 때는 새로운 객체를 생성해야 하지만, StringBuffer는 가변성을 가지고 있어 append() 등의 메서드를 통해 문자열을 변경할 수 있습니다."
    ]
  },
  {
    "id": "android-30",
    "question": "LiveData를 사용할 때 MutableLiveData의 변수를 get()으로 가져오는 방식과 = 으로 가져오는 방식의 차이는 무엇인가요?",
    "answers": [
      "디컴파일될 때, 게터로(get()) 가져올 때는 MutableLiveData가 LiveData로 형변환되어 가져오지만, 식으로(=) 가져오게 되면 불필요한 LiveData의 변수가 하나 추가되어 그 변수가 반환됩니다."
    ]
  },
  {
    "id": "android-31",
    "question": "gradle에서 api와 implementation의 차이점은 무엇인가요?",
    "answers": [
      "api는 라이브러리의 API와 해당 라이브러리에 의존하는 모듈 간의 컴파일 타임 의존성을 설정하며, implementation은 해당 라이브러리에 대한 의존성이 컴파일 타임에만 설정되고 라이브러리를 사용하는 모듈에는 전파되지 않습니다."
    ]
  },
  {
    "id": "android-32",
    "question": "동일성과 동등성을 어떻게 비교하는지 설명해주세요.",
    "answers": [
      "동등성(equality, ==)은 두 개의 객체의 값이 완전히 동일한지를 비교하며(값 비교, 내부적으로 equals를 호출합니다), 동일성(identity, ===)은 같은 주소를 참조하는지를 비교합니다(주소 값 비교, 식별자를 기반으로 객체를 판단합니다)."
    ]
  },
  {
    "id": "android-33",
    "question": "Companion object에 대해 설명해주세요.",
    "answers": [
      "Companion object는 클래스가 메모리에 적재될 때 함께 생성되는 객체로서(static과 유사하게 동작합니다) 변수에 할당이 가능하고, 변수를 통해 멤버를 참조할 수 있습니다(static과는 달리 더 많은 일을 할 수 있습니다)."
    ]
  }
]