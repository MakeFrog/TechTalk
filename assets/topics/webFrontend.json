[
  {
    "id": "webFrontend-1",
    "question": "브라우저 렌더링 원리에 대해서 설명해보세요.",
    "answers": [
      "브라우저 렌더링은 HTML, CSS, JavaScript 등의 웹 페이지 자원을 브라우저가 화면에 그리는 과정을 말합니다. 브라우저 렌더링 원리와 순서는 크게 다음과 같은 단계로 구성됩니다.",
      "먼저 DOM을 생성합니다. 브라우저는 HTML 문서를 파싱하여 DOM 트리를 생성합니다. 이때, HTML 태그를 노드로 변환하고, 노드간의 계층 관계를 형성합니다.",
      "두 번째로 CSSOM을 생성합니다. 브라우저는 CSS 파일을 파싱하여 CSSOM 트리를 생성합니다. 이때, CSS 속성을 노드로 변환하고, 노드간의 계층 관계를 형성합니다.",
      "세 번째로 DOM 트리와 CSSOM을 결합하여 렌더 트리를 생성합니다. 이때, 실제 화면에 표시될 요소만을 선택하여 렌더 트리를 형성합니다. 이제, 브라우저는 렌더 트리를 이용하여 각 요소의 크기와 위치를 계산하는 과정인 레이아웃을 거쳐 화면에 요소를 그리는 페인팅 과정을 거치게 됩니다. 이때, 요소의 배경, 테두리, 글자 등을 그리게 됩니다."
    ]
  },
  {
    "id": "webFrontend-2",
    "question": "MVVM 패턴과 Flux 패턴의 차이점에 대해서 설명해보세요.",
    "answers": [
      "MVVM과 Flux 패턴의 주요 차이점은 데이터 흐름 및 관리 방식에 있습니다.",
      "MVVM은 View와 ViewModel 사이에 양방향 데이터 바인딩을 통해 데이터를 주고받는 반면, Flux는 단방향 데이터 흐름을 따릅니다.",
      "MVVM에서는 ViewModel이 Model 역할을 수행하고, View와 ViewModel 사이에서 데이터를 중계합니다. 반면 Flux에서는 데이터 흐름이 Action -> Dispatcher -> Store -> View로 이어지며, 각 부분이 엄격하게 분리되어 단일 책임을 갖습니다.",
      "이러한 구조는 Flux를 사용한 코드를 테스트하기 쉽게 만듭니다.",
      "반면 MVVM에서는 양방향 데이터 바인딩으로 인해 테스트하기 어려울 수 있습니다. 주로 MVVM은 Angular, Vue.js와 같은 프레임워크에서 사용되고, Flux는 React에서 주로 사용됩니다."
    ]
  },
  {
    "id": "webFrontend-3",
    "question": "RESTful API에 대해 설명해주세요.",
    "answers": [
      "RESTful API는 HTTP 프로토콜을 기반으로하는 웹 서비스 아키텍처입니다.",
      "자원, 메소드, 메시지 등을 정의하여 클라이언트와 서버 간의 통신을 가능하게 합니다. 또한, RESTful API는 표준 HTTP 메소드(GET, POST, PUT, DELETE)를 사용하여 서버와 통신합니다."
    ]
  },
  {
    "id": "webFrontend-4",
    "question": "HTTP 메소드에서 PUT과 PATCH의 차이에 대해 설명해주세요.",
    "answers": [
      "PUT과 PATCH는 모두 HTTP 메서드로, 리소스의 수정을 요청하는 데 사용됩니다.",
      "그러나 PUT은 전체 리소스의 교체를 위해 사용되고, PATCH는 리소스의 일부를 수정하기 위해 사용됩니다."
    ]
  },
  {
    "id": "webFrontend-5",
    "question": "웹 프로토콜에 대해서 간단하게 설명해주세요.",
    "answers": [
      "웹 프로토콜은 웹 상에서 정보를 주고받기 위한 통신 규약이며, HTTP(Hypertext Transfer Protocol)를 가장 일반적으로 사용합니다."
    ]
  },
  {
    "id": "webFrontend-6",
    "question": "HTTP와 HTTPS의 차이점을 말해주세요.",
    "answers": [
      "HTTP는 데이터가 암호화되지 않고 평문으로 전송되므로 보안에 취약합니다.",
      "HTTPS는 보안 소켓 계층(SSL/TLS)을 통해 통신하므로 데이터의 안전성을 보장합니다."
    ]
  },
  {
    "id": "webFrontend-7",
    "question": "HTTP 메소드에서 GET과 POST의 차이에 대해 설명해주세요.",
    "answers": [
      "GET은 서버로부터 정보를 요청할 때 사용되며, URL에 데이터를 붙여서 전송합니다.",
      "POST는 서버에 정보를 제출할 때 사용되며, 요청의 데이터를 HTTP 요청 본문에 담아서 전송합니다."
    ]
  },
  {
    "id": "webFrontend-8",
    "question": "로컬 스토리지, 세션 스토리지, 쿠키의 차이에 대해서 설명해주세요.",
    "answers": [
      "로컬 스토리지는 사용자의 로컬 브라우저에 데이터를 저장하여 영구적으로 보존됩니다.",
      "세션 스토리지는 브라우저 세션이 유지되는 동안 데이터를 저장하며, 세션이 종료되면 삭제됩니다.",
      "쿠키는 브라우저에 데이터를 저장하며, 만료일을 지정하여 일정 기간 동안 유지됩니다."
    ]
  },
  {
    "id": "webFrontend-9",
    "question": "JWT에 대해 간단하게 설명해주세요.",
    "answers": [
      "JWT(Json Web Token)은 웹 토큰 기반의 인증 토큰으로, 정보를 안전하게 전송하기 위한 표준 방법 중 하나입니다."
    ]
  },
  {
    "id": "webFrontend-10",
    "question": "CORS에 대해서 설명해주세요.",
    "answers": [
      "CORS(Cross-Origin Resource Sharing)는 웹 애플리케이션의 보안 정책 중 하나입니다.",
      "웹 브라우저의 스크립트에서 실행되는 웹 애플리케이션에서는 동일 출처 정책(Same-Origin Policy)에 의해 다른 출처에서 리소스를 요청할 수 없습니다.",
      "CORS는 이러한 제한을 완화하여 서로 다른 출처 간의 리소스 공유를 허용합니다.",
      "서로 다른 출처 간에 데이터를 주고받을 때, 보안 상의 문제가 발생할 수 있으며, 이를 해결하기 위해 CORS 정책을 사용합니다.",
      "CORS는 서버가 특정 리소스에 대한 접근을 승인하도록 허용하는 HTTP 헤더를 사용하여 동작합니다.",
      "이를 통해 클라이언트에서 특정 출처로부터 리소스를 요청할 때, 서버가 이를 허용하도록 설정할 수 있습니다."
    ]
  },
  {
    "id": "webFrontend-11",
    "question": "쿠키, 세션, 토큰에 대해서 설명해주세요.",
    "answers": [
      "쿠키는 사용자의 컴퓨터에 저장되는 정보로, 웹사이트가 사용자를 구별하고 상태를 기억하는 데 사용됩니다.",
      "세션은 서버가 사용자를 식별하고 상태를 유지하기 위해 사용하는 방법입니다. 세션은 서버에 저장되므로 클라이언트에게는 세션 ID만 전달됩니다.",
      "토큰은 클라이언트가 로그인한 후에 발급되며, 이를 통해 클라이언트는 인증이나 자격 증명을 확인할 수 있습니다.",
      "토큰은 특별한 알고리즘을 사용하여 생성되며, 이를 통해 위조를 방지하고 안전하게 인증을 수행할 수 있습니다."
    ]
  },
  {
    "id": "webFrontend-12",
    "question": "MVC와 MVVM 패턴의 차이를 설명해주세요.",
    "answers": [
      "MVC(Model-View-Controller)는 소프트웨어를 세 가지의 역할로 구성하여 설계하는 디자인 패턴입니다.",
      "MVVM(Model-View-ViewModel)은 MVC 패턴의 확장으로, View와 Model 간의 의존성을 제거하기 위해 ViewModel을 도입한 패턴입니다."
    ]
  },
  {
    "id": "webFrontend-13",
    "question": "CSR과 SSR의 차이를 설명해주세요.",
    "answers": [
      "CSR(Client-Side Rendering)은 브라우저에서 JavaScript를 사용하여 동적으로 페이지를 생성하는 방식이며, 초기 로딩 속도가 빠르지만 SEO에 취약합니다.",
      "SSR(Server-Side Rendering)은 서버에서 페이지를 렌더링하여 전체 페이지를 생성한 후에 클라이언트에게 전달하는 방식으로, SEO에 유리하지만 초기 로딩 속도가 느릴 수 있습니다."
    ]
  },
  {
    "id": "webFrontend-14",
    "question": "SPA와 MPA의 차이를 설명해주세요.",
    "answers": [
      "SPA(Single Page Application)는 한 개의 페이지로 이루어진 웹 애플리케이션으로, 페이지 간의 전환 없이 동적으로 콘텐츠를 로드합니다.",
      "MPA(Multiple Page Application)는 여러 개의 페이지로 이루어진 웹 애플리케이션으로, 각 페이지가 별도의 HTML을 가지고 있으며 전통적인 웹 애플리케이션 형태입니다."
    ]
  },
  {
    "id": "webFrontend-15",
    "question": "웹팩(Webpack)과 바벨(Babel)은 무엇인가요?",
    "answers": [
      "웹팩(Webpack)은 모듈 번들러로, 프로젝트의 자원들(JavaScript, CSS, 이미지 등)을 하나 또는 여러 개의 번들로 묶어서 최적화된 정적 자원을 생성합니다.",
      "바벨(Babel)은 JavaScript의 최신 문법을 사용하여 코드를 작성할 수 있게 해주는 도구로, 이를 구형 브라우저에서도 동작할 수 있는 호환성 있는 코드로 변환합니다."
    ]
  },
  {
    "id": "webFrontend-16",
    "question": "깊은 복사와 얕은 복사의 차이점을 말해주세요.",
    "answers": [
      "깊은 복사(Deep Copy)는 객체의 모든 속성을 재귀적으로 복사하여 새로운 객체를 생성하는 것이며, 복사된 객체는 원본 객체와 독립적입니다.",
      "얕은 복사(Shallow Copy)는 객체의 주소 값만을 복사하여 새로운 객체를 생성하는 것이며, 복사된 객체는 원본 객체와 동일한 객체를 참조합니다."
    ]
  },
  {
    "id": "webFrontend-17",
    "question": "크로스 브라우징에 대해서 설명해주세요.",
    "answers": [
      "크로스 브라우징(Cross Browsing)은 여러 웹 브라우저 간에 동일한 사용자 경험을 제공하기 위한 웹 개발 방법론이며, 웹 페이지가 모든 브라우저에서 일관되게 동작하도록 보장하는 것을 목표로 합니다."
    ]
  },
  {
    "id": "webFrontend-18",
    "question": "Semantic HTML은 무엇인가요?",
    "answers": [
      "Semantic HTML은 의미론적 HTML로, 콘텐츠의 의미를 구조화하여 표현하는 것을 말합니다.",
      "예를 들어, <div>와 같은 구조적인 태그 대신 <header>, <footer>, <nav> 등의 의미 있는 태그를 사용하여 웹 페이지의 구조를 명확하게 표현합니다."
    ]
  }
]
