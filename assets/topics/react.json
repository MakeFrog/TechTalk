[
  {
    "id": "react-1",
    "question": " 리액트 리스트 (list)에 왜 key를 사용해야 하나요?",
    "answers": [
      "리액트에서 리스트를 렌더링할 때 각 항목에 고유한 식별자인 \"key\"를 제공해야 합니다. 이는 리액트가 각 항목을 식별하고 추적할 수 있도록 도와줍니다.",
      "만약 key가 없거나 중복된다면 리액트는 각 항목을 올바르게 업데이트하지 못하고 성능에 영향을 줄 수 있습니다. key는 업데이트, 재사용 및 효율적인 렌더링에 필요한 항목 식별을 도와주는 중요한 요소입니다."
    ]
  },
  {
    "id": "react-2",
    "question": "Virtual DOM은 무엇인가요?",
    "answers": [
      "Virtual DOM은 실제 DOM(Document Object Model)의 가상 복제물로, 애플리케이션의 UI를 구성하는 HTML 요소들을 메모리 내에서 구현한 것입니다. 컴포넌트가 재 렌더링될 때, Virtual DOM은 이전 DOM과 변경된 내용을 비교하여 업데이트할 요소의 목록을 생성합니다. 이렇게 함으로써 전체 DOM을 다시 렌더링할 필요 없이 변경 사항이 있는 부분만 업데이트하여 성능을 향상시킵니다. 이는 DOM에 필요한 최소한의 변경만을 수행함으로써 효율성을 극대화하는 장점을 가지고 있습니다."
    ]
  },
  {
    "id": "react-3",
    "question": "이벤트 버블링에 대해서 설명해주세요.",
    "answers": [
      "이벤트 버블링(event bubbling)은 HTML에서 이벤트가 발생했을 때, 해당 요소에서 이벤트가 처리된 후, 상위 요소로 이벤트가 전파되는 현상을 말합니다. 이벤트 버블링은 이벤트가 전파되는 동안 부모 요소에서도 이벤트를 감지할 수 있다는 장점이 있습니다. 즉, 이벤트를 처리하는 핸들러 함수를 부모 요소에 등록해놓으면, 자식 요소에서 발생한 이벤트도 모두 처리할 수 있습니다. 이를 활용하면, 여러 개의 하위 요소에서 발생하는 이벤트를 하나의 이벤트 핸들러로 바인딩하는 이벤트 위임 처리를 할 수 있습니다.",
      "버블링 및 캡쳐링을 방지하기 위해서는 이벤트 객체의 stopPropagation() 메서드를 사용하여 이벤트 전파를 중지시키거나, 이벤트 핸들러에서 이벤트가 발생한 요소를 확인하여 처리해야 합니다."
    ]
  },
  {
    "id": "react-4",
    "question": "호이스팅에 대해 설명해보세요.",
    "answers": [
      "호이스팅은 변수와 함수 선언이 스코프(scope)의 최상단으로 올려져 실행되는 것을 의미합니다. 이로 인해 선언 전에 사용하는 경우 오류가 발생할 수 있습니다."
    ]
  },
  {
    "id": "react-5",
    "question": "클로저란 무엇인가요?",
    "answers": [
      "함수가 선언될 때 자동으로 생성되는 렉시컬 환경에 대한 설명입니다. 이러한 렉시컬 환경은 스코프 체인(scope chain)을 형성하게 되는데, 스코프 체인은 함수가 선언될 때의 모든 변수와 함수를 포함하는 렉시컬 스코프(lexical scope)를 형성합니다. 외부 함수가 실행 되고 반환된 후에도 외부 함수의 범위 내의 함수에 체이닝을 할 수 있는 함수 입니다. 정보를 은닉하기 위해서 주로 사용 합니다.\n"
    ]
  },

  {
    "id": "react-6",
    "question": "\"==\" 와 \"===\"의 차이는 무엇인가요?",
    "answers": [
      "\"==\"는 동등 연산자로, 두 값을 비교할 때 형변환(type coercion)을 수행합니다. 즉, 비교하는 값의 데이터 타입이 다르더라도 자동으로 형변환을 수행한 후에 비교합니다. 이러한 형변환은 때로 예측하지 못한 결과를 초래할 수 있으므로, \"==\"를 사용할 때는 조심해야 합니다. \"===\"는 일치 연산자로, 두 값이 데이터 타입과 값이 모두 같은지 비교합니다. 따라서 \"===\"를 사용하면 형변환 없이 정확한 값을 비교할 수 있습니다. 이러한 일치 연산자를 사용하는 것이 더 안전하고 예측 가능한 결과를 얻을 수 있습니다."
    ]
  },

  {
    "id": "react-7",
    "question": "브라우저 렌더링 원리에 대해서 설명해보세요",
    "answers": [
      "브라우저 렌더링은 HTML, CSS, JavaScript 등의 웹 페이지 자원을 브라우저가 화면에 그리는 과정을 말합니다. 브라우저 렌더링 원리와 순서는 크게 다음과 같은 단계로 구성됩니다.",
      "먼저 DOM을 생성합니다. 브라우저는 HTML 문서를 파싱하여 DOM 트리를 생성합니다. 이때, HTML 태그를 노드로 변환하고, 노드간의 계층 관계를 형성합니다.",
      "두 번째로 CSSOM을 생성합니다. 브라우저는 CSS 파일을 파싱하여 CSSOM 트리를 생성합니다. 이때, CSS 속성을 노드로 변환하고, 노드간의 계층 관계를 형성합니다.",
      "세 번째로 DOM트리와 CSSOM을 결합하여 렌더 트리를 생성 합니다. 이때, 실제 화면에 표시될 요소만을 선택하여 렌더 트리를 형성합니다.\n이제, 브라우저는 렌더 트리를 이용하여 각 요소의 크기와 위치를 계산하는 과정인 레이아웃을 거쳐 화면에 요소를 그리는 페인팅 과정을 거치게 됩니다. 이때, 요소의 배경, 테두리, 글자 등을 그리게 됩니다.\n"
    ]
  },
  {
    "id": "react-8",
    "question": "async/await에 대해 설명해보세요",
    "answers": [
      "async/await는 비동기적인 작업을 처리할 수 있는 ES2017 문법 입니다. async 함수를 정의하면 함수 내부에서 await 키워드를 이용하여 비동기적으로 처리되는 작업이 완료될 때까지 기다린 후, 결과값을 반환하는 처리를 할 수 있습니다. async/await는 Promise를 기반으로 하며, 코드를 보다 간결하고 직관적으로 작성할 수 있도록 해줍니다. async 함수는 항상 Promise 객체를 반환하며, await 키워드를 이용하여 비동기 처리 결과를 기다립니다."
    ]
  },
  {
    "id": "react-9",
    "question": "state와 props의 차이는 무엇인가요",
    "answers": [
      "props는 부모 컴포넌트에서 자식 컴포넌트로 전달되는 데이터입니다. props는 수정이 불가하며 직접 쓰이거나 다른 값을 계산하는 데 사용됩니다. state는 컴포넌트의 생명주기 동안에 수정될 수 있는 내부 데이터로, 재 렌더링시에도 유지됩니다."
    ]
  },
  {
    "id": "react-10",
    "question": "prop으로 전달되는 값의 type을 어떻게 강제하나요? 또, prop이 필수적으로 전달되게끔 어떻게 강제할 수 있나요?",
    "answers": [
      "컴포넌트의 props의 타입을 확인하기 위해서는 prop-types 패키지 (리액트 15.5까지는 리액트에 내장되어 있습니다.)를 이용하여 기대하는 값의 타입과 prop이 필수인지 여부를 선언해줄 수 있습니다."
    ]
  },
  {
    "id": "react-11",
    "question": "prop drilling은 무엇이고, 어떻게 피할 수 있나요?",
    "answers": [
      "prop drilling은 부모 컴포넌트에서 하위 컴포넌트로 데이터를 전달할 때 발생하는 것으로, props를 전달하는 것 이외에는 props를 필요로 하지 않는 다른 컴포넌트를 통해 \"drilling\"이 됩니다.",
      "컴포넌트를 리팩토링하고, 컴포넌트를 더 작은 컴포넌트로 세분화하지 않고, 상태를 가장 가까운 부모 컴포넌트와 공유함으로써 prop drilling을 회피할 수 있습니다. 레벨상 멀리 떨어진 컴포넌트와 state를 공유해야 할 때는, 리액트의 Context API 또는 Redux와 같은 state 관리 라이브러리를 사용할 수 있습니다."
    ]
  },
  {
    "id": "react-12",
    "question": "제어 컴포넌트와 비제어 컴포넌트의 차이는 무엇인가요?",
    "answers": [
      "제어 컴포넌트는 리액트의 상태(state)를 통해 form 엘리먼트의 값을 관리하는 반면, 비제어 컴포넌트는 DOM에 있는 엘리먼트의 값을 직접 다룹니다.",
      "제어 컴포넌트는 내부 상태를 사용하여 입력 값을 추적하고, 값이 변경될 때마다 리액트가 자동으로 업데이트합니다. 반면 비제어 컴포넌트는 외부 코드와 더 쉽게 통합되며, 특히 리액트가 아닌 코드와 함께 사용될 때 유용합니다."
    ]
  },

  {
    "id": "react-13",
    "question": "생명주기 메소드는 무엇인가요",
    "answers": [
      "클래스 기반 컴포넌트들은 마운트되었을 때나 언마운트될 때와 같이 생명주기 중 특정 시점에 호출되는 특별한 메소드를 선언할 수 있습니다",
      "컴포넌트가 필요할 때 세팅 및 해체, 타이머를 설정하거나 브라우저 이벤트에 바인딩할 시 유용합니다.,"
    ]
  },
  {
    "id": "react-14",
    "question": "React hook에 대해 설명해주세요",
    "answers": [
      "React Hooks는 함수형 컴포넌트에서 상태(state)와 생명주기(lifecycle) 기능을 사용할 수 있게 해주는 React의 기능입니다",
      "이전에는 클래스 컴포넌트에서만 상태를 관리하고 라이프사이클 메서드를 사용할 수 있었지만, Hooks를 사용하면 함수형 컴포넌트에서도 상태를 관리하고 라이프사이클 메서드를 이용할 수 있어 코드를 더 간결하게 작성할 수 있습니다.",
      "useState, useEffect 등의 내장된 Hook들을 사용하여 상태를 관리하고 부수 효과를 처리할 수 있습니다."
    ]
  },
  {
    "id": "react-15",
    "question": "Babel에 대해서 설명해주세요",
    "answers": [
      "Babel은JavaScript 컴파일러이고 최신 버전의 JavaScript로 코드를 작성하는데 도움이 되는 도구입니다. ",
      "JavaScript의 버전업그레이드로 인한 최신 문법을 가진 ES6+ 코드를 런타임 환경인 브라우저가 인식하고 실행하는데 문제가 생시고 효율성과 유지보수등의 이유로 코드는 ES6+ 로 구현해야 하는데 실행환경인 모든 브라우저가 최신 문법을 다 지원하지 못하기에 버전 차이가 발생하게되는데, Babel을 통해 관련 문제를 해결할 수 있습니다."
    ]
  },
  {
    "id": "react-16",
    "question": "useEffect에 대해서 설명해주세요",
    "answers": [
      "useEffect: 함수형 컴포넌트에서 생명주기 메서드를 사용하기 위한 Hook입니다. useEffect 함수는 컴포넌트가 렌더링 될 때마다 실행되며, 해당 컴포넌트가 마운트될 때, 업데이트될 때, 언마운트될 때 등 다양한 타이밍에 실행할 수 있습니다."
    ]
  },
  {
    "id": "react-17",
    "question": "useContext에 대해서 설명해주세요",
    "answers": [
      "컴포넌트 트리 안에서 전역적으로 상태를 관리하기 위한 Hook입니다. createContext를 통해 생성한 Context 객체를 사용하여 컴포넌트 간에 값을 공유할 수 있습니다."
    ]
  },
  {
    "id": "react-18",
    "question": "클래스 컴포넌트와 함수형 컴포넌트의 차이는 무엇인가요?",
    "answers": [
      "클래스 컴포넌트는 JavaScript 클래스로 작성되어 상태(state)를 가질 수 있고 라이프사이클 메서드를 사용할 수 있으며 this 키워드를 통해 인스턴스에 접근합니다. 반면 함수형 컴포넌트는 함수로 작성되어 상태를 가질 수 없고, React Hooks를 사용하여 상태 관리 및 라이프사이클 기능을 구현하며 함수형 프로그래밍의 장점을 취합니다."
    ]
  },
  {
    "id": "react-19",
    "question": "Key에 대해서 설명해주세요",
    "answers": [
      "key는 엘리먼트 리스트를 만들 때 포함해야 하는 특수한 문자열 어트리뷰트입니다. Key는 React가 어떤 항목을 변경, 추가 또는 삭제할지 식별하는 것을 돕습니다. key는 엘리먼트에 안정적인 고유성을 부여하기 위해 배열 내부의 엘리먼트에 지정해야 합니다",
      "리액트에서 key는 컴포넌트 리스트를 렌더링 했을 때 어떤 원소에 변동이 있었는지 알아내기 위해 사용하며 유동적인 데이터를 다룰 때, 리스트의 중간에 새로운 컴포넌트가 추가될 수도, 삭제될 수도 있습니다."
    ]
  },
  {
    "id": "react-20",
    "question": "React.memo에 대해서 설명해주세요",
    "answers": [
      "key는 엘리먼트 리스트를 만들 때 포함해야 하는 특수한 문자열 어트리뷰트입니다. Key는 React가 어떤 항목을 변경, 추가 또는 삭제할지 식별하는 것을 돕습니다. key는 엘리먼트에 안정적인 고유성을 부여하기 위해 배열 내부의 엘리먼트에 지정해야 합니다",
      "리액트에서 key는 컴포넌트 리스트를 렌더링 했을 때 어떤 원소에 변동이 있었는지 알아내기 위해 사용하며 유동적인 데이터를 다룰 때, 리스트의 중간에 새로운 컴포넌트가 추가될 수도, 삭제될 수도 있습니다."
    ]
  },
  {
    "id": "react-21",
    "question": "React.memo에 대해서 설명해주세요",
    "answers": [
      "React.memo는 Higher-Order Components(HOC)입니다. (HOC란 컴포넌트를 인자로 받아서 새로운 컴포넌트를 return해주는 구조의 함수) . 하나의 컴포넌트가 똑같은 props를 넘겨 받았을 때 같은 결과를 렌더링 하고 있다면 React.memo를 사용하여 불필요한 컴포넌트 렌더링을 방지 할 수 있으며 React.memo를 사용할 경우 이전과 같은 props가 들어올때는 렌더링 과정을 스킵하고 가장 최근에 렌더링된 결과를 재사용 합니다"
    ]
  },
  {
    "id": "react-22",
    "question": "useCallback에 대해서 설명해주세요",
    "answers": [
      "useCallback은 리액트의 렌더링 성능을 위해서 제공되는 Hook입니다. 컴포넌트가 렌더링 될 때마다 내부적으로 사용된 함수가 새롭게 생성되는 경우, 자식 컴포넌트에 Prop으로 새로 생성된 함수가 넘겨지게 되면 불필요한 리렌더링이 일어날 수 있습니다.",
      "useCallback 함수는 첫 번째 인수로 입력된 콜백의 메모이제이션 버전을 반환합니다. 반환된 메모이제이션 버전은 콜백의 의존성이 변경되었을 때만 변경되며, 이는 불필요한 렌더링을 방지하기 위해 참조의 동일성에 의존적인 최적화된 자식 컴포넌트에 콜백을 전달할 때 유용합니다. 예로 React의 Memo로 감싸진 컴포넌트에 프롭으로 전달하는 경우, 자주 사용됩니다."
    ]
  },
  {
    "id": "react-23",
    "question": "useRef에 대해서 설명해주세요",
    "answers": [
      "useRef 은 .current 프로퍼티로 전달된 인자로 초기화된 변경 가능한 ref 객체를 반환하며, 이 객체는 컴포넌트의 전 생애주기를 통해 유지될 것입니다. 이 전 생애주기를 통한 유지란 컴포넌트가 리렌더링되어도 값이 유지가된다는 뜻입니다."
    ]
  },
  {
    "id": "react-24",
    "question": "함수형 컴포넌트의 장점에 대해서 설명해주세요",
    "answers": [
      "클래스형 컴포넌트보다 선언이 간편합니다.",
      "클래스형 컴포넌트보다 메모리 자원을 덜 사용합니다.",
      "프로젝트 빌드 후 배포할 때 결과물의 파일 크기가 더 작습니다",
      "이전에는 라이프사이클 API를 사용하지 못한다는 단점이 있었는데, 이제는 16.8부터 지원하는 Hook을 통해 이한 단점이 사라졌습니다."
    ]
  }
]