[
  {
    "id": "react-1",
    "question": "리액트 리스트(list)에 왜 key를 사용해야 하나요?",
    "answers": [
      "리액트에서 리스트를 렌더링할 때 각 항목에 고유한 식별자인 'key'를 제공해야 합니다. 이는 리액트가 각 항목을 식별하고 추적할 수 있도록 도와줍니다.",
      "만약 key가 없거나 중복된다면 리액트는 각 항목을 올바르게 업데이트하지 못하고 성능에 영향을 줄 수 있습니다. key는 업데이트, 재사용 및 효율적인 렌더링에 필요한 항목 식별을 도와주는 중요한 요소입니다."
    ]
  },
  {
    "id": "react-2",
    "question": "state와 props의 차이는 무엇인가요?",
    "answers": [
      "props는 부모 컴포넌트에서 자식 컴포넌트로 전달되는 데이터입니다.",
      "props는 수정이 불가하며 직접 쓰이거나 다른 값을 계산하는 데 사용됩니다. state는 컴포넌트의 생명주기 동안에 수정될 수 있는 내부 데이터로, 재 렌더링시에도 유지됩니다."
    ]
  },
  {
    "id": "react-3",
    "question": "prop으로 전달되는 값의 type을 어떻게 강제하나요? 또, prop이 필수적으로 전달되게끔 어떻게 강제할 수 있나요?",
    "answers": [
      "컴포넌트의 props의 타입을 확인하기 위해서는 prop-types 패키지 (리액트 15.5까지는 리액트에 내장되어 있습니다.)를 이용하여 기대하는 값의 타입과 prop이 필수인지 여부를 선언해줄 수 있습니다."
    ]
  },
  {
    "id": "react-4",
    "question": "prop drilling은 무엇이고, 어떻게 피할 수 있나요?",
    "answers": [
      "prop drilling은 부모 컴포넌트에서 하위 컴포넌트로 데이터를 전달할 때 발생하는 것으로, props를 전달하는 것 이외에는 props를 필요로 하지 않는 다른 컴포넌트를 통해 'drilling'이 됩니다.",
      "컴포넌트를 리팩토링하고, 컴포넌트를 더 작은 컴포넌트로 세분화하지 않고, 상태를 가장 가까운 부모 컴포넌트와 공유함으로써 prop drilling을 회피할 수 있습니다. 레벨상 멀리 떨어진 컴포넌트와 state를 공유해야 할 때는, 리액트의 Context API 또는 Redux와 같은 state 관리 라이브러리를 사용할 수 있습니다."
    ]
  },
  {
    "id": "react-5",
    "question": "제어 컴포넌트와 비제어 컴포넌트의 차이는 무엇인가요?",
    "answers": [
      "제어 컴포넌트는 리액트의 상태(state)를 통해 form 엘리먼트의 값을 관리하는 반면, 비제어 컴포넌트는 DOM에 있는 엘리먼트의 값을 직접 다룹니다.",
      "제어 컴포넌트는 내부 상태를 사용하여 입력 값을 추적하고, 값이 변경될 때마다 리액트가 자동으로 업데이트합니다. 반면 비제어 컴포넌트는 외부 코드와 더 쉽게 통합되며, 특히 리액트가 아닌 코드와 함께 사용될 때 유용합니다."
    ]
  },
  {
    "id": "react-6",
    "question": "생명주기 메소드는 무엇인가요",
    "answers": [
      "클래스 기반 컴포넌트들은 마운트되었을 때나 언마운트될 때와 같이 생명주기 중 특정 시점에 호출되는 특별한 메소드를 선언할 수 있습니다.",
      "컴포넌트가 필요할 때 세팅 및 해체, 타이머를 설정하거나 브라우저 이벤트에 바인딩할 시 유용합니다."
    ]
  },
  {
    "id": "react-7",
    "question": "React hook에 대해 설명해주세요",
    "answers": [
      "React Hooks는 함수형 컴포넌트에서 상태(state)와 생명주기(lifecycle) 기능을 사용할 수 있게 해주는 React의 기능입니다.",
      "이전에는 클래스 컴포넌트에서만 상태를 관리하고 라이프사이클 메서드를 사용할 수 있었지만, Hooks를 사용하면 함수형 컴포넌트에서도 상태를 관리하고 라이프사이클 메서드를 이용할 수 있어 코드를 더 간결하게 작성할 수 있습니다.",
      "useState, useEffect 등의 내장된 Hook들을 사용하여 상태를 관리하고 부수 효과를 처리할 수 있습니다."
    ]
  },
  {
    "id": "react-8",
    "question": "useEffect에 대해서 설명해주세요",
    "answers": [
      "useEffect: 함수형 컴포넌트에서 생명주기 메서드를 사용하기 위한 Hook입니다. useEffect 함수는 컴포넌트가 렌더링 될 때마다 실행되며, 해당 컴포넌트가 마운트될 때, 업데이트될 때, 언마운트될 때 등 다양한 타이밍에 실행할 수 있습니다."
    ]
  },
  {
    "id": "react-9",
    "question": "useContext에 대해서 설명해주세요",
    "answers": [
      "컴포넌트 트리 안에서 전역적으로 상태를 관리하기 위한 Hook입니다. createContext를 통해 생성한 Context 객체를 사용하여 컴포넌트 간에 값을 공유할 수 있습니다."
    ]
  },
  {
    "id": "react-10",
    "question": "클래스 컴포넌트와 함수형 컴포넌트의 차이는 무엇인가요?",
    "answers": [
      "클래스 컴포넌트는 JavaScript 클래스로 작성되어 상태(state)를 가질 수 있고 라이프사이클 메서드를 사용할 수 있으며 this 키워드를 통해 인스턴스에 접근합니다. 반면 함수형 컴포넌트는 함수로 작성되어 상태를 가질 수 없고, React Hooks를 사용하여 상태 관리 및 라이프사이클 기능을 구현하며 함수형 프로그래밍의 장점을 취합니다."
    ]
  },
  {
    "id": "react-11",
    "question": "Key에 대해서 설명해주세요",
    "answers": [
      "key는 엘리먼트 리스트를 만들 때 포함해야 하는 특수한 문자열 어트리뷰트입니다. Key는 React가 어떤 항목을 변경, 추가 또는 삭제할지 식별하는 것을 돕습니다. key는 엘리먼트에 안정적인 고유성을 부여하기 위해 배열 내부의 엘리먼트에 지정해야 합니다.",
      "리액트에서 key는 컴포넌트 리스트를 렌더링 했을 때 어떤 원소에 변동이 있었는지 알아내기 위해 사용하며 유동적인 데이터를 다룰 때, 리스트의 중간에 새로운 컴포넌트가 추가될 수도, 삭제될 수도 있습니다."
    ]
  },
  {
    "id": "react-12",
    "question": "React.memo에 대해서 설명해주세요",
    "answers": [
      "React.memo는 Higher-Order Components(HOC)입니다. (HOC란 컴포넌트를 인자로 받아서 새로운 컴포넌트를 return해주는 구조의 함수) . 하나의 컴포넌트가 똑같은 props를 넘겨 받았을 때 같은 결과를 렌더링 하고 있다면 React.memo를 사용하여 불필요한 컴포넌트 렌더링을 방지 할 수 있으며 React.memo를 사용할 경우 이전과 같은 props가 들어올때는 렌더링 과정을 스킵하고 가장 최근에 렌더링된 결과를 재사용 합니다"
    ]
  },
  {
    "id": "react-13",
    "question": "React.memo에 대해서 설명해주세요",
    "answers": [
      "React.memo는 Higher-Order Components(HOC)입니다. (HOC란 컴포넌트를 인자로 받아서 새로운 컴포넌트를 return해주는 구조의 함수) . 하나의 컴포넌트가 똑같은 props를 넘겨 받았을 때 같은 결과를 렌더링 하고 있다면 React.memo를 사용하여 불필요한 컴포넌트 렌더링을 방지 할 수 있으며 React.memo를 사용할 경우 이전과 같은 props가 들어올때는 렌더링 과정을 스킵하고 가장 최근에 렌더링된 결과를 재사용 합니다"
    ]
  },
  {
    "id": "react-14",
    "question": "useCallback에 대해서 설명해주세요",
    "answers": [
      "useCallback은 리액트의 렌더링 성능을 위해 제공되는 Hook입니다. 컴포넌트가 렌더링 될 때마다 내부적으로 사용된 함수가 새롭게 생성되는 경우, 자식 컴포넌트에 새로 생성된 함수가 Prop으로 전달되면 불필요한 리렌더링이 발생할 수 있습니다.",
      "useCallback 함수는 입력된 콜백의 메모이제이션 버전을 반환합니다. 반환된 메모이제이션 버전은 콜백의 의존성이 변경되었을 때만 변경되며, 이는 참조의 동일성에 의존적인 최적화된 자식 컴포넌트에 콜백을 전달할 때 유용합니다. React.memo로 감싸진 컴포넌트에 프롭으로 전달하는 경우에 자주 사용됩니다."
    ]
  },
  {
    "id": "react-15",
    "question": "useRef에 대해서 설명해주세요",
    "answers": [
      "useRef는 .current 프로퍼티로 전달된 인자로 초기화된 변경 가능한 ref 객체를 반환합니다. 이 객체는 컴포넌트의 생애주기 동안 유지됩니다. 이 생애주기 유지는 컴포넌트가 리렌더링되어도 값이 유지됨을 의미합니다."
    ]
  },
  {
    "id": "react-16",
    "question": "함수형 컴포넌트의 장점에 대해서 설명해주세요",
    "answers": [
      "함수형 컴포넌트는 선언이 간편하고 가독성이 좋습니다.",
      "클래스형 컴포넌트보다 메모리 자원을 덜 사용합니다.",
      "프로젝트 빌드 후 배포할 때 결과물의 파일 크기가 작습니다.",
      "이전에는 라이프사이클 API를 사용하지 못하는 단점이 있었으나, 16.8부터 도입된 Hook을 통해 이러한 단점이 해결되었습니다."
    ]
  },
  {
    "id": "react-17",
    "question": "React의 Virtual DOM이란 무엇인가요?",
    "answers": [
      "Virtual DOM은 React의 핵심 개념 중 하나로, 실제 DOM에 접근하여 변경사항을 반영하는 대신 가상의 DOM을 메모리에 유지하고 이를 통해 효율적으로 DOM 조작을 수행합니다.",
      "이를 통해 React는 상태 변화에 대한 최소한의 변경만을 실제 DOM에 적용함으로써 성능을 향상시킵니다."
    ]
  },
  {
    "id": "react-18",
    "question": "React 컴포넌트의 라이프사이클 메서드에는 어떤 것들이 있으며 각각 어떤 시점에 호출되나요?",
    "answers": [
      "라이프사이클 메서드에는 마운트, 업데이트, 언마운트 단계가 있습니다.",
      "마운트 단계에서는 constructor, render, componentDidMount가 호출됩니다.",
      "업데이트 단계에서는 shouldComponentUpdate, render, componentDidUpdate가 호출됩니다.",
      "언마운트 단계에서는 componentWillUnmount가 호출됩니다."
    ]
  },
  {
    "id": "react-19",
    "question": "React에서 이벤트 핸들링을 하는 방법은 무엇인가요?",
    "answers": [
      "React에서 이벤트 핸들링은 일반적인 HTML과 유사하지만 camelCase를 사용합니다.",
      "예를 들어, HTML의 onclick은 React에서는 onClick으로 사용됩니다.",
      "함수를 호출하거나 상태를 업데이트하기 위해 이벤트 핸들러 내에서 콜백 함수를 호출할 수 있습니다."
    ]
  },
  {
    "id": "react-20",
    "question": "React에서 조건부 렌더링을 하는 방법은 무엇인가요?",
    "answers": [
      "조건부 렌더링은 JSX 내부에서 JavaScript 표현식을 사용하여 구현됩니다.",
      "if나 삼항 연산자, && 연산자 등을 사용하여 조건부 렌더링을 할 수 있습니다."
    ]
  },
  {
    "id": "react-21",
    "question": "React에서 props를 업데이트하는 방법은 무엇인가요?",
    "answers": [
      "부모 컴포넌트에서 자식 컴포넌트로 전달되는 props는 자식 컴포넌트 내부에서 직접 수정할 수 없습니다.",
      "부모 컴포넌트에서 props를 업데이트하면 자동으로 자식 컴포넌트의 props도 업데이트됩니다."
    ]
  },
  {
    "id": "react-22",
    "question": "React에서 컴포넌트 간의 통신을 하는 방법은 무엇인가요?",
    "answers": [
      "부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다.",
      "자식 컴포넌트에서 부모 컴포넌트로 데이터를 전달하려면 콜백 함수를 props로 전달하여 부모 컴포넌트에서 실행시키는 방식을 사용할 수 있습니다."
    ]
  },
  {
    "id": "react-23",
    "question": "React에서의 컴포넌트 라이프사이클은 어떻게 되나요?",
    "answers": [
      "React v16 이후에는 라이프사이클이 엄격히 나눠지지 않으며, 대신 라이프사이클 함수를 사용할 수 있습니다.",
      "이로써 컴포넌트의 마운트, 업데이트, 언마운트 등의 단계에서 특정 작업을 수행할 수 있습니다."
    ]
  },
  {
    "id": "react-24",
    "question": "React에서 컴포넌트 스타일링을 하는 방법은 무엇인가요?",
    "answers": [
      "React에서 컴포넌트를 스타일링하는 방법에는 CSS, Inline Styling, CSS Modules, CSS-in-JS 등이 있습니다.",
      "각각의 방법은 장단점이 있으며 프로젝트의 규모와 성격에 따라 선택할 수 있습니다."
    ]
  },
  {
    "id": "react-25",
    "question": "React Router의 역할은 무엇이며 어떻게 사용하나요?",
    "answers": [
      "React Router는 싱글 페이지 애플리케이션에서 클라이언트 사이드 라우팅을 관리하는 데 사용됩니다.",
      "BrowserRouter나 HashRouter와 같은 라우터 컴포넌트를 사용하여 라우팅을 설정하고, Route 컴포넌트를 사용하여 경로에 따라 해당 컴포넌트를 렌더링합니다."
    ]
  },
  {
    "id": "react-26",
    "question": "React에서 상태를 관리하는 방법은 무엇이 있으며 각각의 특징은 무엇인가요?",
    "answers": [
      "React에서 상태를 관리하는 방법에는 클래스 컴포넌트의 state와 함수형 컴포넌트에서 제공하는 useState Hook이 있습니다.",
      "클래스 컴포넌트의 state는 this.state를 통해 접근하고 setState를 통해 업데이트합니다.",
      "useState Hook은 배열 구조 분해를 통해 상태와 상태를 업데이트하는 함수를 반환합니다."
    ]
  },
  {
    "id": "react-27",
    "question": "React의 에러 처리 방법은 무엇인가요?",
    "answers": [
      "React에서 에러 처리를 위해 componentDidCatch 라이프사이클 메서드나 Error Boundary를 사용할 수 있습니다.",
      "이를 통해 컴포넌트 트리 전체에서 에러를 관리하고 처리할 수 있습니다."
    ]
  },
  {
    "id": "react-28",
    "question": "React에서의 테스트는 어떻게 이루어지나요?",
    "answers": [
      "React의 테스트는 주로 Jest와 같은 테스트 러너를 사용하여 이루어집니다.",
      "또한 React Testing Library나 Enzyme과 같은 라이브러리를 사용하여 컴포넌트의 동작을 테스트할 수 있습니다."
    ]
  },
  {
    "id": "react-29",
    "question": "React에서 이전 상태를 기반으로 상태를 업데이트하는 방법은 무엇인가요?",
    "answers": [
      "클래스 컴포넌트에서는 setState 메서드를 사용할 때 콜백 함수를 전달하여 이전 상태를 기반으로 상태를 업데이트할 수 있습니다.",
      "함수형 컴포넌트에서는 useState Hook을 사용할 때 이전 상태를 인자로 받는 콜백 함수를 전달하여 상태를 업데이트할 수 있습니다."
    ]
  }
]