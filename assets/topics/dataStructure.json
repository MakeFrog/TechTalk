[
  {
    "id": "dataStructure-1",
    "question": "자료구조란 무엇인가요?",
    "answers": [
      "자료구조는 데이터를 구조적으로 조직화하는 방법이며, 데이터를 효율적으로 저장하고 조작하기 위해 사용됩니다."
    ]
  },
  {
    "id": "dataStructure-2",
    "question": "Array와 LinkedList의 장/단점에 대해 설명해주세요.",
    "answers": [
      "Array는 인덱스(index)로 해당 원소(element)에 접근할 수 있어 찾고자 하는 원소의 인덱스 값을 알고 있으면 O(1)에 해당 원소로 접근할 수 있습니다.",
      "즉, RandomAccess가 가능해 속도가 빠르다는 장점이 있습니다.하지만 삽입 또는 삭제의 과정에서 각 원소들을 shift 해줘야 하는 비용이 생겨 이 경우 시간 복잡도는 O(n)이 된다는 단점이 있습니다.",
      "이 문제점을 해결하기 위한 자료구조가 linkedlist입니다. 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있기 때문에 이 부분만 다른 값으로 바꿔주면 삽입과 삭제를 O(1)로 해결할 수 있습니다.하지만LinkedList는 원하는 위치에 한 번에 접근할 수 없다는 단점이 있습니다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 Search 과정에 있어서 첫번째 원소부터 다 확인해봐야 합니다."
    ]
  },
  {
    "id": "dataStructure-3",
    "question": "스택과 큐의 차이는 무엇인가요?",
    "answers": [
      "스택은 후입선출(LIFO)의 구조를 가지고 있고, 큐는 선입선출(FIFO)의 구조를 가지고 있습니다."
    ]
  },
  {
    "id": "dataStructure-4",
    "question": "이중 연결 리스트와 단일 연결 리스트의 차이점은 무엇인가요?",
    "answers": [
      "이중 연결 리스트는 각 노드가 이전 노드와 다음 노드의 주소를 가지고 있지만, 단일 연결 리스트는 다음 노드의 주소만을 가지고 있습니다."
    ]
  },
  {
    "id": "dataStructure-5",
    "question": "트리와 그래프의 차이는 무엇인가요?",
    "answers": [
      "트리는 계층적인 구조를 가지며, 그래프는 노드와 노드를 연결하는 간선으로 이루어진 자료 구조입니다."
    ]
  },
  {
    "id": "dataStructure-6",
    "question": "이진 트리와 이진 탐색 트리(BST)의 차이는 무엇인가요?",
    "answers": [
      "이진 트리는 각 노드가 최대 두 개의 자식을 가질 수 있지만, 이진 탐색 트리는 부모 노드보다 왼쪽 자식은 작고 오른쪽 자식은 큰 값을 가집니다.",
      "이진 탐색 트리는 왼쪽 트리의 모든 값은 반드시 부모 노드보다 작아야 하고, 오른쪽 트리의 값은 부모 노드보다 커야 하는 특징이 있습니다."
    ]
  },
  {
    "id": "dataStructure-7",
    "question": "AVL 트리와 레드-블랙 트리의 차이점은 무엇인가요?",
    "answers": [
      "AVL 트리는 균형이 잡혀있는 이진 탐색 트리이고, 레드-블랙 트리는 균형을 유지하는 트리로, 회전 연산을 사용해 균형을 유지합니다."
    ]
  },
  {
    "id": "dataStructure-8",
    "question": "해시 테이블의 작동 원리는 무엇인가요?",
    "answers": [
      "해시 테이블은 키-값 쌍을 저장하기 위한 자료 구조로, 해시 함수를 사용하여 키를 해시값으로 변환하고 이를 인덱스로 활용합니다."
    ]
  },
  {
    "id": "dataStructure-9",
    "question": "해시 충돌이 발생하는 경우에는 어떻게 처리하나요?",
    "answers": [
      "해시 충돌이 발생하면 체이닝 또는 오픈 어드레싱을 사용하여 처리할 수 있습니다."
    ]
  },
  {
    "id": "dataStructure-10",
    "question": "해시 함수의 요구 사항은 무엇인가요?",
    "answers": [
      "해시 함수는 고유한 입력에 대해 고유한 출력을 생성해야 하며, 충돌을 최소화해야 합니다."
    ]
  },
  {
    "id": "dataStructure-11",
    "question": "선형 탐색과 이진 탐색의 차이점은 무엇인가요?",
    "answers": [
      "선형 탐색은 순차적으로 원소를 비교하며 찾고자 하는 값을 찾는 반면, 이진 탐색은 정렬된 배열에서 중간 값을 비교하여 검색 범위를 반으로 줄여가며 탐색합니다."
    ]
  },
  {
    "id": "dataStructure-12",
    "question": "그래프를 표현하는 방법에는 어떤 것이 있나요?",
    "answers": [
      "인접 행렬과 인접 리스트가 있습니다."
    ]
  },
  {
    "id": "dataStructure-13",
    "question": "BFS(Breadth-First Search)와 DFS(Depth-First Search)의 차이는 무엇인가요?",
    "answers": [
      "BFS는 너비 우선으로 탐색하고, DFS는 깊이 우선으로 탐색합니다."
    ]
  },
  {
    "id": "dataStructure-14",
    "question": "힙(heap)의 개념과 사용 사례는 무엇인가요?",
    "answers": [
      "힙은 최댓값 또는 최솟값을 빠르게 찾기 위한 완전 이진 트리입니다."
    ]
  },
  {
    "id": "dataStructure-15",
    "question": "트리 순회 방법에는 어떤 것들이 있나요?",
    "answers": [
      "전위 순회, 중위 순회, 후위 순회가 있습니다."
    ]
  },
  {
    "id": "dataStructure-16",
    "question": "스택을 활용한 재귀 함수의 동작 원리를 설명해주세요.",
    "answers": [
      "스택을 이용하여 함수가 호출될 때마다 호출 스택에 저장하고, 함수가 반환될 때 스택에서 꺼내어 실행합니다."
    ]
  },
  {
    "id": "dataStructure-17",
    "question": "그래프에서 사이클을 검출하는 방법은 무엇인가요?",
    "answers": [
      "DFS를 사용하여 그래프를 탐색하며, 역방향 간선을 발견하면 사이클로 판단합니다."
    ]
  },
  {
    "id": "dataStructure-18",
    "question": "퀵 정렬(Quick Sort)의 원리와 시간 복잡도를 설명해주세요.",
    "answers": [
      "퀵 정렬은 분할 정복 알고리즘을 기반으로 하며, 평균적으로 O(n log n)의 시간 복잡도를 가집니다."
    ]
  },
  {
    "id": "dataStructure-19",
    "question": "버블 정렬(Bubble Sort)의 원리와 시간 복잡도를 설명해주세요.",
    "answers": [
      "버블 정렬은 인접한 두 원소를 비교하여 정렬하는 방식으로, 시간 복잡도는 O(n^2)입니다."
    ]
  },
  {
    "id": "dataStructure-20",
    "question": "병합 정렬(Merge Sort)의 원리와 시간 복잡도를 설명해주세요.",
    "answers": [
      "병합 정렬은 분할 정복 알고리즘을 사용하여 배열을 반으로 나눈 후, 정렬된 부분 배열을 병합하는 방식으로 동작합니다. 시간 복잡도는 항상 O(n log n)입니다."
    ]
  },
  {
    "id": "dataStructure-21",
    "question": "Priority Queue(우선순위 큐)에 대해 설명해주세요.",
    "answers": [
      "우선순위 큐는 들어간 순서에 상관없이 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조입니다.",
      "우선순위 큐 구현 방식에는 배열, 연결 리스트, 힙이 있고, 그중 힙 방식이 worst case라도 시간 복잡도 O(logN)을 보장하기 때문에 일반적으로 완전 이진트리 형태의 힙을 이용해 구현합니다."
    ]
  },
  {
    "id": "dataStructure-22",
    "question": "Array와 ArrayList의 차이점에 대해 설명해주세요.",
    "answers": [
      "Array는 크기가 고정적이고, ArrayList는 크기가 가변적입니다.",
      "Array는 초기화 시 메모리에 할당되어 ArrayList보다 속도가 빠르고, ArrayList는 데이터 추가 및 삭제 시 메모리를 재할당하기 때문에 속도가 Array보다 느립니다."
    ]
  },
  {
    "id": "dataStructure-23",
    "question": "해시 테이블(Hash Table)과 시간 복잡도에 대해 설명해주세요",
    "answers": [
      "해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조입니다.",
      "빠른 검색 속도를 제공하는 이유는 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문입니다. 각 Key값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 O(1)의 시간 복잡도로 데이터를 조회합니다. 하지만 index값이 충돌이 발생한 경우 Chanining에 연결된 리스트들까지 검색해야 하므로 O(N)까지 증가할 수 있습니다."
    ]
  },
  {
    "id": "dataStructure-24",
    "question": " RBT(Red-Black Tree)에 대해 설명해주세요.",
    "answers": [
      "RBT(Red-Black Tree)는 BST를 기반으로 하는 트리 형식 자료구조이며, RBT는 BST의 삽입, 삭제 연산 과정에서 발생할 수 있는 문제점을 해결하기 위해 만들어졌습니다.",
      "BST를 기반으로 하기 때문에 당연히 BST의 특징을 모두 갖습니다.노드의 child가 없을 경우 child를 가리키는 포인터는 NIL 값을 저장합니다. 이러한 NIL들을 leaf node로 간주합니다."
    ]
  }
]