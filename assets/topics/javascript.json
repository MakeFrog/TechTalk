[
  {
    "id": "javascript-1",
    "question": "동기(Sync)와 비동기(Async)의 차이점을 설명해 주세요.",
    "answers": [
      "동기와 비동기는 작업을 수행할 때 완료 여부에 따라 구분됩니다.",
      "동기적 작업에서는 요청을 보내고 나서 해당 작업의 완료 응답을 기다리지만, 비동기적 작업에서는 요청의 응답을 기다리지 않고 다음 동작을 실행합니다. 동기 작업은 직렬적으로 수행되어야 하지만, 비동기 작업은 병렬적으로 수행될 수 있습니다."
    ]
  },
  {
    "id": "javascript-2",
    "question": "Blocking과 Non-Blocking의 차이를 설명해 주세요.",
    "answers": [
      "Blocking과 Non-Blocking은 작업을 수행할 때 제어권이 누구에게 있는지에 따라 구분됩니다.",
      "Blocking 작업에서는 해당 작업이 완료될 때까지 다른 작업을 수행할 수 없지만, Non-Blocking 작업에서는 해당 작업이 완료되기 전에도 다른 작업을 수행할 수 있습니다."
    ]
  },
  {
    "id": "javascript-3",
    "question": "콜백함수에 대해 설명해 주세요.",
    "answers": [
      "콜백 함수는 다른 함수에 매개변수로 전달되어 사용되는 함수입니다.",
      "주로 어떤 이벤트에 의해 호출되며, 이벤트가 발생하면 해당 함수가 실행되어 원하는 작업을 수행합니다. 이를테면, 비동기적 작업에서 콜백 함수는 작업이 완료되었을 때 실행되어 처리 결과를 반환하거나 적절한 작업을 수행할 수 있습니다."
    ]
  },
  {
    "id": "javascript-4",
    "question": "이벤트 위임에 대해 설명하세요.",
    "answers": [
      "이벤트 위임은 이벤트 리스너를 하위 요소에 추가하는 대신 상위 요소에 추가하는 기법입니다. 리스너는 DOM의 event bubbling으로 인해 하위 요소에서 이벤트가 발생될 때마다 실행됩니다.",
      "이로인해 각 하위 항목에 이벤트 핸들러를 연결하지 않고, 상위 요소에 하나의 단일 핸들러만 필요하기 때문에 메모리 사용 공간이 줄어듭니다.",
      "제거된 요소에서 핸들러를 해제하고 새 요소에 대해 이벤트를 바인딩할 필요가 없습니다."
    ]
  },
  {
    "id": "javascript-5",
    "question": "this가 JavaScript에서 어떻게 작동하는지 설명하세요.",
    "answers": [
      "this 키워드는 JavaScript에서 실행 컨텍스트에 따라 참조하는 객체를 가리킵니다.",
      "호출되는 방법에 따라 동적으로 결정되며, 전역 컨텍스트에서는 전역 객체를 가리키고, 함수 내부에서는 호출 방법에 따라 달라집니다. 메서드 호출 시에는 해당 메서드를 호출한 객체를, 생성자 함수 호출 시에는 새로 생성되는 객체를 가리킵니다."
    ]
  },
  {
    "id": "javascript-6",
    "question": "프로토타입 상속이 어떻게 작동하는지 설명하세요.",
    "answers": [
      "프로토타입 상속은 JavaScript에서 객체 간에 코드 및 속성을 공유하는 메커니즘입니다.",
      "JavaScript 객체는 다른 객체에 대한 참조인 proto 프로퍼티를 가지고 있습니다. 이것은 객체의 프로퍼티에 접근할 때 사용됩니다. 객체의 프로퍼티에 접근할 때 해당 객체에 해당 프로퍼티가 없으면 JavaScript 엔진은 객체의 __proto__를 확인하고, 더 이상 프로퍼티를 찾을 때까지 __proto__의 __proto__를 찾습니다.",
      "이러한 과정을 통해 프로토타입 체인을 형성하게 되며, 객체 간에 속성과 메소드를 공유할 수 있습니다. 이러한 동작은 고전적인 상속을 모방하지만, 사실은 객체 간의 위임(delegation)에 더 가깝습니다."
    ]
  },
  {
    "id": "javascript-7",
    "question": "null, undefined, undeclared의 차이점은 무엇인가요? 또한 어떻게 이 상태들에 대한 확인을 할 것인가요?",
    "answers": [
      "null은 명시적으로 값이 할당된 상태입니다. 변수가 null을 가지고 있다면, 그것은 값이 없음을 나타냅니다.",
      "undefined는 값이 할당되지 않은 상태입니다. 변수가 undefined를 가지고 있다면, 그것은 값을 예상할 수 없음을 의미합니다. 이는 자바스크립트 엔진이 변수를 초기화할 때 주로 발생합니다.",
      "undeclared 변수는 이전에 var, let, const를 사용하여 선언되지 않은 식별자에 값을 할당할 때 생성됩니다. 이 변수는 현재 범위 외부에 전역으로 정의됩니다.",
      "이러한 상태들을 확인하기 위해서는 보통 엄격한 동등 연산자(===)를 사용하여 값을 비교합니다. 예를 들어, null을 확인할 때는 === null을 사용하고, undefined를 확인할 때는 typeof 연산자를 사용하여 'undefined'와 비교합니다. undeclared 변수를 확인하기 위해서는 변수가 선언되었는지 여부를 확인하거나, 해당 변수를 사용하기 전에 try/catch 블록으로 감싸서 ReferenceError가 발생하는지 확인할 수 있습니다."
    ]
  },
  {
    "id": "javascript-8",
    "question": ".forEach 루프와 .map() 루프 사이의 주요 차이점을 설명할 수 있나요?",
    "answers": [
      "forEach는 배열을 반복하면서 주어진 작업을 수행하고, 반환값이 없습니다. 반면에 map()은 배열을 반복하면서 각 요소를 변환한 새로운 배열을 반환합니다.",
      "기본적으로 forEach는 작업을 수행하고 끝나지만, map()은 새로운 배열을 생성하여 각 요소를 변환합니다."
    ]
  },
  {
    "id": "javascript-9",
    "question": ".call과 .apply의 차이점은 무엇인가요",
    "answers": [
      ".call과 .apply는 모두 함수를 호출하는 메서드이지만, 주요 차이점은 인수를 전달하는 방식입니다.",
      "call은 각각의 인수를 직접 전달하는 반면에, .apply는 배열 형태로 인수를 전달합니다."
    ]
  },
  {
    "id": "javascript-10",
    "question": "Function.prototype.bind에 대해 설명하세요.",
    "answers": [
      "bind() 메소드는 호출될 때, this 키워드가 주어진 인자 값으로 설정되고, 새로운 함수가 호출될 때, 앞쪽의 매개변수도 자신의 인자를 사용해 미리 순서대로 채워놓은 새로운 함수를 반환합니다.",
      "주로 다른 함수로 전달하고자 하는 클래스의 메소드에서 this의 값을 바인딩할 때 가장 유용합니다. 특히 React 컴포넌트에서 자주 사용됩니다."
    ]
  },
  {
    "id": "javascript-11",
    "question": "Ajax에 대한 개념과 장단점에 대해 설명해주세요",
    "answers": [
      "Ajax는 클라이언트 측에서 사용되는 웹 개발 기술의 집합으로, 페이지를 새로 고치지 않고도 서버와 비동기적으로 데이터를 교환할 수 있게 해줍니다. 이를 통해 사용자 경험을 향상시키고 네트워크 부하를 줄일 수 있습니다. 또한, 페이지 재로드로 인한 상태 손실을 방지하여 상태를 관리할 수 있어서, SPA의 장점을 제공합니다.",
      "그러나 Ajax의 단점으로는 동적 웹 페이지가 북마크하기 어렵고, 브라우저에서 JavaScript가 비활성화된 경우 작동하지 않는 등의 문제가 있습니다. 또한, 일부 웹 크롤러는 JavaScript를 실행하지 않아 동적으로 로드된 콘텐츠를 볼 수 없을 수 있습니다. 이러한 단점들은 SPA의 단점과도 유사합니다."
    ]
  },
  {
    "id": "javascript-12",
    "question": "\"function foo() {}\"와 \"var foo = function() {}\" 사이에서 foo 사용의 차이에 대해 설명해주세요.",
    "answers": [
      "두 방식의 주요 차이는 함수의 호이스팅과 관련이 있습니다.",
      "함수 선언 방식인 첫 번째 방식에서는 함수 바디가 호이스팅되지만, 함수 표현식인 두 번째 방식에서는 함수 바디가 호이스팅되지 않습니다. 이것은 변수와 동일한 호이스팅 동작을 보이며, 함수 표현식을 정의하기 전에 호출하려고 시도하면 \"Uncaught TypeError: XXX is not a function\"과 같은 에러가 발생합니다."
    ]
  },
  {
    "id": "javascript-13",
    "question": "고차 함수(higher-order function)의 정의는 무엇인가요?",
    "answers": [
      "고차 함수는 다른 함수를 매개 변수로 받거나 함수를 반환하는 함수를 의미합니다. 이는 함수를 데이터로 다루는 것을 가능하게 하며, 반복적으로 수행되는 어떤 연산을 추상화하여 코드를 더 간결하고 유연하게 만드는데 도움을 줍니다.",
      "예를 들어, JavaScript에서는 map, filter, reduce와 같은 배열 메서드가 고차 함수의 대표적인 예입니다. 이러한 함수들은 다른 함수를 인자로 받아서 처리하고 결과를 반환합니다. 또한, 함수를 반환하는 형태의 고차 함수 역시 많이 사용됩니다. 이러한 함수들을 사용하여 코드를 모듈화하고 재사용성을 높일 수 있습니다."
    ]
  },
  {
    "id": "javascript-14",
    "question": "클로저(Closure)란 무엇이며 어떻게 사용되나요?",
    "answers": [
      "클로저는 내부 함수가 외부 함수의 변수에 접근할 수 있는 것을 가리킵니다.",
      "외부 함수가 실행을 마쳤더라도 내부 함수가 외부 변수에 접근할 수 있고, 이러한 메커니즘을 통해 private 변수나 함수를 모방할 수 있습니다.",
      "클로저는 주로 비동기 작업, 콜백 함수, 모듈 패턴 등에서 사용됩니다."
    ]
  },
  {
    "id": "javascript-15",
    "question": "호이스팅(Hoisting)이란 무엇이며, JavaScript에서 어떻게 작동하나요?",
    "answers": [
      "호이스팅은 변수 및 함수 선언이 스코프의 최상단으로 옮겨지는 것을 가리킵니다. 즉, 코드가 실행되기 전에 변수 및 함수 선언이 메모리에 저장되어 처리됩니다.",
      "변수는 선언 단계에서 메모리에 할당되지만 초기화 단계는 실제 할당이 이루어지는 지점으로, 초기화 단계 이전에 변수를 참조하면 undefined가 됩니다.",
      "함수 선언은 전체가 호이스팅되며 함수 표현식은 변수만 호이스팅되고 할당은 그대로 남아 있습니다."
    ]
  },
  {
    "id": "javascript-16",
    "question": "이벤트 버블링에 대해서 설명해주세요.",
    "answers": [
      "이벤트 버블링(event bubbling)은 HTML에서 이벤트가 발생했을 때, 해당 요소에서 이벤트가 처리된 후, 상위 요소로 이벤트가 전파되는 현상을 말합니다. 이벤트 버블링은 이벤트가 전파되는 동안 부모 요소에서도 이벤트를 감지할 수 있다는 장점이 있습니다. 즉, 이벤트를 처리하는 핸들러 함수를 부모 요소에 등록해놓으면, 자식 요소에서 발생한 이벤트도 모두 처리할 수 있습니다. 이를 활용하면, 여러 개의 하위 요소에서 발생하는 이벤트를 하나의 이벤트 핸들러로 바인딩하는 이벤트 위임 처리를 할 수 있습니다.",
      "버블링 및 캡쳐링을 방지하기 위해서는 이벤트 객체의 stopPropagation() 메서드를 사용하여 이벤트 전파를 중지시키거나, 이벤트 핸들러에서 이벤트가 발생한 요소를 확인하여 처리해야 합니다."
    ]
  },
  {
    "id": "javascript-17",
    "question": "이벤트 캡처에 대해 설명하세요.",
    "answers": [
      "이벤트 캡처는 이벤트가 발생한 요소에서 시작하여 하위 요소로 전파되는 현상입니다.",
      "이벤트 캡처 단계에서 이벤트 핸들러가 호출되고 그 후에 이벤트가 해당 요소에서 발생합니다.",
      "이벤트 캡처 단계에서 이벤트 핸들러가 호출되는 것은 브라우저에 따라 설정할 수 있습니다."
    ]
  },
  {
    "id": "javascript-18",
    "question": "ES6의 중요한 기능 중 몇 가지를 설명하세요.",
    "answers": [
      "화살표 함수(Arrow Functions): 간결한 문법과 자체적인 this를 가지는 특징을 가진 함수 표현식입니다.",
      "let 및 const: 블록 스코프를 가지는 변수 선언 키워드로서, var의 호이스팅 및 스코프 이슈를 해결합니다.",
      "클래스(Class): 프로토타입 기반의 객체지향 프로그래밍을 보다 명확하고 간편하게 지원합니다.",
      "템플릿 리터럴(Template Literals): 문자열을 보다 쉽게 다룰 수 있는 문법적 편의를 제공합니다.",
      "구조 분해 할당(Destructuring Assignment): 객체나 배열의 속성을 해체하여 개별 변수에 할당하는 기능입니다."
    ]
  },
  {
    "id": "javascript-19",
    "question": "Promise에 대해 설명하고 사용하는 이유를 말해주세요.",
    "answers": [
      "Promise는 비동기 작업의 성공 또는 실패를 나타내는 객체입니다.",
      "비동기 작업이 완료되면 이행(fulfilled) 상태가 되며 성공한 결과를 반환하고, 실패하면 거부(rejected) 상태가 되며 에러를 반환합니다.",
      "Promise는 콜백 헬(callback hell)을 해결하고 코드를 보다 직관적이고 가독성 있게 만듭니다.",
      "또한 비동기 작업의 성공과 실패를 명확하게 처리할 수 있습니다."
    ]
  },
  {
    "id": "javascript-20",
    "question": "Event Loop에 대해 설명하세요.",
    "answers": [
      "Event Loop는 JavaScript 런타임 환경에서 비동기 콜백 함수 및 이벤트를 관리하는 메커니즘입니다.",
      "JavaScript는 단일 스레드 언어이지만 비동기 작업을 효율적으로 처리하기 위해 Event Loop를 사용합니다.",
      "이벤트 루프는 호출 스택(Call Stack), 태스크 큐(Task Queue), 백그라운드(Browser APIs, Web APIs, Timer 등)로 구성됩니다.",
      "호출 스택에 있는 작업이 모두 실행되면 이벤트 루프는 태스크 큐에 있는 작업을 호출 스택으로 이동시킵니다. 이러한 프로세스를 통해 비동기 작업을 순차적으로 처리할 수 있습니다."
    ]
  },
  {
    "id": "javascript-21",
    "question": "콜백 지옥(Callback Hell)이란 무엇이며, 어떻게 해결할 수 있나요?",
    "answers": [
      "콜백 지옥은 비동기 콜백 함수를 중첩하여 코드가 복잡하고 가독성이 떨어지는 상황을 가리킵니다.",
      "이는 콜백 함수 안에 또 다른 콜백 함수가 중첩되어 있어 코드가 수직적으로 길어지고 이해하기 어려워집니다.",
      "콜백 지옥을 해결하기 위해 Promise, async/await 등의 비동기 처리 방식을 사용할 수 있습니다.",
      "Promise를 사용하면 비동기 작업을 보다 구조화된 방식으로 처리할 수 있으며, async/await는 Promise를 보다 간결하게 사용할 수 있도록 도와줍니다."
    ]
  },
  {
    "id": "javascript-22",
    "question": "JavaScript에서 'use strict'는 무엇을 의미하며 어떤 장점이 있나요?",
    "answers": [
      "'use strict'는 JavaScript 코드를 엄격한 모드로 실행하도록 지시하는 문자열입니다.",
      "이를 사용하면 더 많은 예외와 오류를 발생시켜 안전성을 높일 수 있습니다.",
      "또한, 기존의  silent errors가 예외로 변환되므로 디버깅이 용이해집니다.",
      "'use strict'를 사용하면 예약어로 사용되는 일부 식별자를 변수 이름으로 사용할 수 없게 되므로 코드의 가독성도 향상됩니다."
    ]
  },
  {
    "id": "javascript-23",
    "question": "클래스(Class)와 프로토타입(Prototype)의 차이점은 무엇인가요?",
    "answers": [
      "클래스(Class)는 ES6에서 도입된 개념으로, 객체지향 프로그래밍에서 객체를 생성하기 위한 템플릿입니다.",
      "프로토타입(Prototype)은 JavaScript의 객체 지향 프로그래밍에서 상속을 구현하기 위한 메커니즘입니다.",
      "클래스는 인스턴스를 생성하기 위한 템플릿으로 사용되며, 클래스 내부에는 생성자, 메서드 등이 정의됩니다.",
      "프로토타입은 객체 간의 공유되는 속성과 메서드를 정의하여 메모리를 절약하고 상속을 구현합니다."
    ]
  },
  {
    "id": "javascript-24",
    "question": "Arrow Function에 대해 설명하세요. 그리고 일반 함수와의 차이점은 무엇인가요?",
    "answers": [
      "화살표 함수(Arrow Function)는 ES6에서 도입된 새로운 함수 표현식입니다.",
      "일반 함수와 다르게 화살표 함수는 항상 익명 함수입니다.",
      "화살표 함수는 함수를 간결하게 표현할 수 있으며, this를 바인딩하지 않고 상위 스코프의 this를 그대로 사용합니다.",
      "또한, 화살표 함수는 자신의 arguments 객체를 가지지 않습니다."
    ]
  },
  {
    "id": "javascript-25",
    "question": "JavaScript의 비동기 처리 방식에 대해 설명하세요.",
    "answers": [
      "JavaScript는 단일 스레드 언어이지만 비동기 작업을 처리하기 위해 다양한 방식을 제공합니다.",
      "콜백 함수, Promise, async/await 등이 대표적인 비동기 처리 방식입니다.",
      "콜백 함수는 비동기 작업이 완료되었을 때 호출되는 함수로, 콜백 지옥을 유발할 수 있습니다.",
      "Promise는 비동기 작업의 성공 또는 실패를 나타내는 객체로, then() 및 catch() 메서드를 통해 처리합니다.",
      "async/await는 Promise를 더 쉽게 사용할 수 있도록 하는 ES8(ES2017)의 비동기 처리 방식입니다."
    ]
  },
  {
    "id": "javascript-26",
    "question": "Prototype이 무엇이며 JavaScript에서 어떻게 작동하나요?",
    "answers": [
      "Prototype은 JavaScript 객체 간의 상속을 구현하는 메커니즘입니다.",
      "JavaScript의 모든 객체는 자신의 부모 역할을 하는 Prototype을 가지고 있습니다.",
      "객체의 속성 또는 메서드에 접근할 때 해당 객체에 속성 또는 메서드가 없으면 자동으로 Prototype으로 이동하여 검색합니다.",
      "이러한 메커니즘을 통해 객체 간의 속성 및 메서드를 공유할 수 있습니다."
    ]
  },
  {
    "id": "javascript-27",
    "question": "\"==\" 와 \"===\"의 차이는 무엇인가요?",
    "answers": [
      "\"==\"는 동등 연산자로, 두 값을 비교할 때 형변환(type coercion)을 수행합니다. 즉, 비교하는 값의 데이터 타입이 다르더라도 자동으로 형변환을 수행한 후에 비교합니다. 이러한 형변환은 때로 예측하지 못한 결과를 초래할 수 있으므로, \"==\"를 사용할 때는 조심해야 합니다.",
      "\"===\"는 일치 연산자로, 두 값이 데이터 타입과 값이 모두 같은지 비교합니다. 따라서 \"===\"를 사용하면 형변환 없이 정확한 값을 비교할 수 있습니다. 이러한 일치 연산자를 사용하는 것이 더 안전하고 예측 가능한 결과를 얻을 수 있습니다."
    ]
  }
]