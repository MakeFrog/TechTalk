[
  {
    "id": "ios-1",
    "question": "Optional이란 무엇인가요?",
    "answers": [
      "Optional은 값이 있을 수도 없을 수도 있는 변수나 상수를 나타내는 Swift의 특별한 형태입니다. 값이 있으면 해당 값을 갖고, 없으면 nil 값을 가집니다. 이를 통해 안전하게 nil을 다룰 수 있습니다."
    ]
  },
  {
    "id": "ios-2",
    "question": "Delegate란 무엇이며 어떻게 사용하나요",
    "answers": [
      "Delegate는 객체가 다른 객체의 동작을 대신 처리할 수 있도록 하는 디자인 패턴입니다. 주로 프로토콜을 사용하여 구현되며, 객체 사이의 상호작용을 유연하게 만듭니다",
      "Delegate는 UITableView가 데이터를 표시하고 사용자 입력을 처리하는 방법을 정의합니다."
    ]
  },
  {
    "id": "ios-3",
    "question": "ARC (Automatic Reference Counting)이란 무엇이며 어떻게 작동하나요?",
    "answers": [
      "ARC는 Objective-C 및 Swift에서 메모리 관리를 자동화하는 기술입니다. 객체가 참조하는 변수의 수를 추적하여 객체가 더 이상 필요하지 않을 때 메모리에서 해제합니다. 이를 통해 개발자가 수동으로 메모리를 관리하는 번거로움을 피할 수 있습니다."
    ]
  },
  {
    "id": "ios-4",
    "question": "iOS 앱 생명주기는 어떻게 구성되어 있나요?",
    "answers": [
      "iOS 앱은 다양한 상태를 가지며, 각 상태에서는 특정한 작업을 수행할 수 있습니다. 주요 상태에는 Not Running, Inactive, Active, Background, Suspended 등이 있습니다. 앱은 사용자 상호작용이나 시스템 이벤트에 따라 이러한 상태를 전환하며, 이를 통해 앱의 생명주기를 관리합니다."
    ]
  },
  {
    "id": "ios-5",
    "question": "Delegate와 Notification의 차이는 무엇인가요",
    "answers": [
      "Delegate는 일대일 통신을 위한 디자인 패턴으로, 객체 간의 상호작용을 도와줍니다. Notification은 일대다 통신을 위한 메커니즘이며, 여러 객체들에게 이벤트를 알리는 데 사용됩니다."
    ]
  },
  {
    "id": "ios-6",
    "question": "Core Data란 무엇이며, 어떻게 사용하나요?",
    "answers": [
      "Core Data는 Apple의 데이터 저장 및 관리 프레임워크로, 데이터베이스에 대한 추상화 계층을 제공합니다. Core Data를 사용하여 데이터를 영구적으로 저장하고, 관리하고, 검색할 수 있습니다."
    ]
  },
  {
    "id": "ios-7",
    "question": "Swift의 Access Control에는 어떤 종류가 있나요",
    "answers": [
      "Swift의 Access Control에는 open, public, internal, fileprivate, private 다섯 가지가 있습니다. 이들은 접근 권한을 제한하는 데 사용됩니다."
    ]
  },
  {
    "id": "ios-8",
    "question": "iOS에서 다양한 데이터 저장 방법은 어떤 것이 있나요?",
    "answers": [
      "iOS에서 데이터를 저장하는 방법으로는 UserDefaults, CoreData, 파일 시스템, 네트워크 서버, Keychain 등이 있습니다."
    ]
  },
  {
    "id": "ios-9",
    "question": "Protocol이란 무엇이며, 어떻게 사용하나요?",
    "answers": [
      "Protocol은 메서드, 속성 및 다른 멤버들의 요구 사항을 정의하는 추상화된 타입입니다. 클래스, 구조체 또는 열거형은 프로토콜을 채택하여 해당 요구 사항을 충족시킬 수 있습니다."
    ]
  },
  {
    "id": "ios-10",
    "question": "Swift의 Extension이란 무엇이며, 어떻게 사용하나요",
    "answers": [
      "Extension은 기존 클래스, 구조체, 열거형 또는 프로토콜에 새로운 기능을 추가하는 기능입니다. 타입의 정의를 변경하지 않고도 기능을 확장할 수 있습니다."
    ]
  },
  {
    "id": "ios-11",
    "question": "Dispatch Queue의 Serial Queue에 대해서 설명해보세요",
    "answers": [
      "직렬 큐(serial queue)는 작업을 한 번에 하나씩 처리하는 작업 큐입니다. 직렬 큐는 스레드에 먼저 할당한 작업이 완전히 끝나야 큐에서 대기 중인 다음 작업을 스레드에 새로 할당합니다."
    ]
  },
  {
    "id": "ios-12",
    "question": "let과 var의 차이는 무엇인가요?",
    "answers": [
      "let은 한 번 할당된 값을 변경할 수 없는 상수를 선언하기 위한 키워드이고, var는 값을 변경할 수 있는 변수를 선언하기 위한 키워드입니다. 즉, let은 주소에 대한 포인터를 바꿀 수 없다는 의미이며, 이는 클래스 인스턴스의 var로 선언된 변수의 값을 변경하는 것은 가능하다는 것을 의미합니다"
    ]
  },
  {
    "id": "ios-13",
    "question": "upcasting과 downcasting의 차이는 무엇인가요?",
    "answers": [
      "Upcasting은 서로 상속 관계에 있는 클래스에서 자식 클래스를 부모 클래스로 타입캐스팅하는 것을 의미하며, 이를 위해 as 키워드를 사용합니다. 이와 달리 Downcasting은 부모 클래스로부터 자식 클래스로의 타입캐스팅을 의미하며, 이때는 as? 또는 as! 키워드를 사용합니다. 컴파일 타임에 업캐스팅이 가능한지 여부가 판별되기 때문에 컴파일이 되면 항상 성공합니다."
    ]
  },
  {
    "id": "ios-14",
    "question": "== 연산자와 === 연산자는 어떻게 다른가요?",
    "answers": [
      "== 연산자는 값을 비교하는데 사용되며, === 연산자는 참조 값을 비교하는데 사용됩니다."
    ]
  },
  {
    "id": "ios-15",
    "question": "function과 method의 차이를 말해보세요.",
    "answers": [
      "function은 재사용 가능한 코드 블록을 의미하며, method는 클래스, 구조체, 열거형에 포함되는 function을 의미합니다. 함수는 클래스나 구조체 등 특정 타입에 종속되지 않고 독립적으로 정의될 수 있지만, 메소드는 특정한 타입에 속해있어 해당 타입의 인스턴스에 의해 호출됩니다."
    ]
  },
  {
    "id": "ios-16",
    "question": "mutaing 키워드의 의미를 설명해보세요.",
    "answers": [
      "mutating 키워드는 스위프트에서 값 타입인 구조체나 열거형의 메서드에서 해당 인스턴스의 프로퍼티를 수정할 수 있도록 허용하는 키워드입니다. 일반적으로 값 타입의 프로퍼티는 해당 인스턴스의 메서드 내에서 수정할 수 없습니다. 하지만 mutating 키워드가 붙은 메서드를 실행하면 해당 메서드에서 인스턴스의 프로퍼티를 변경할 수 있게 됩니다. 이때, 메서드 내에서 프로퍼티를 변경하면 스위프트는 변경된 값을 가진 새로운 인스턴스를 생성하여 반환하고, 이를 통해 현재 인스턴스를 대체합니다. 이러한 방식을 통해 구조체의 불변성을 유지하면서도 내부의 값을 수정할 수 있습니다."
    ]
  },
  {
    "id": "ios-17",
    "question": "프로토콜과 클래스의 차이를 설명해보세요",
    "answers": [
      "클래스는 인스턴스 메서드의 실제 구현체를 가지고 있지만 프로토콜은 메서드의 인터페이스만 가지고 있습니다. 프로토콜이 구현체를 가지게 하려면 프로토콜의 Extension을 만들어 구현체를 작성할 수 있습니다."
    ]
  },
  {
    "id": "ios-18",
    "question": "inout은 언제 사용하면 좋을까요?",
    "answers": [
      "inout 파라미터를 사용하면 값 타입 변수가 저장된 주소의 값을 함수 안과 밖에서 동일하게 사용하게 됩니다. 따라서 함수가 입력과 동일한 출력을 제공하고, 함수 내에서 적용된 변경사항이 함수 외부에서도 동일하게 적용되어야할 때 사용할 수 있습니다.",
      "Swap과 같이 함수가 인자로 전달된 변수의 값을 변경해야 하는 경우에 inout이 유용하게 사용될 수 있습니다."
    ]
  },
  {
    "id": "ios-19",
    "question": "연산 프로퍼티와 클로저를 가지는 저장 프로퍼티의 차이를 설명해보세요.",
    "answers": [
      "클로저를 가지는 저장 프로퍼티는 프로퍼티의 생성시점에 클로저를 생성하고 사용합니다. 또한 var 키워드로 생성되어 있다면 다른 클로저를 할당해주는 것도 가능합니다",
      "연산 프로퍼티는 프로퍼티를 참조할 때마다 클로저를 생성하고 실행합니다."
    ]
  },
  {
    "id": "ios-20",
    "question": "메서드 안에서 언제 self를 사용해야할까요?",
    "answers": [
      "파라미터의 이름이 인스턴스의 프로퍼티 이름과 겹칠 경우에 인스턴스의 프로퍼티임을 명시하기 위해서 self를 사용할 수 있습니다."
    ]
  },
  {
    "id": "ios-21",
    "question": "강한 참조는 무엇이고 왜 필요한가요?",
    "answers": [
      "강한 참조는 참조 타입 인스턴스를 변수에 할당하는 것을 의미합니다. 스위프트의 ARC(자동 참조 계산)는 강한 참조에 참조 카운트를 증가시키고, 강한 참조가 해제되면 참조 카운트를 감소시킵니다. 참조 카운트가 0이 되면 메모리에서 인스턴스를 해제합니다. 따라서 강한 참조가 있어야만 스위프트에서 참조 타입의 인스턴스를 메모리에 유지할 수 있습니다",
      "사이클을 방지하고 메모리 누수를 방지하기 위해 필요합니다"
    ]
  },
  {
    "id": "ios-22",
    "question": "strong, weak, unowned reference는 각각 언제 사용할까요?",
    "answers": [
      "메모리에서 인스턴스가 해제되는 것을 막기 위해 강한 참조인 strong reference를 사용할 수 있습니다. strong reference는 참조 카운트를 1 증가시키기 때문입니다. 기본적으로 참조의 방향이 단방향으로 이루어지면 strong reference는 항상 안전합니다.",
      "weak reference는 참조 카운트를 증가시키지 않습니다. weak reference는 항상 var 로 선언되는 옵셔널 타입이 되어야합니다. weak으로 참조하고 있던 인스턴스가 해제될 수 있기 때문입니다. 순환 참조의 가능성이 있는 상황에서 weak을 통해 방지할 수 있습니다.",
      "unowned reference는 weak 과 동일하게 참조 카운트를 증가시키지 않습니다. 그리고 동시에 unowned 로 선언된 변수는 nil을 가질 수 없다는 특징이 있습니다. unowned 로 참조하고 있던 인스턴스가 해제되면 unowned 는 nil이 아니라 더 이상 참조할 수 없는 주소를 계속 참조하게 되고 unowned 변수를 참조하려고 하면 런타임 에러가 발생합니다. 따라서 unowned는 해당 변수가 참조하는 인스턴스보다 먼저 해제되는 것이 확실한 상황에서만 사용해야 합니다. Optional이 아니기 때문에 캡쳐 리스트나 옵셔널 바인딩을 사용하지 않아도 된다는 장점이 있습니다."
    ]
  },
  {
    "id": "ios-23",
    "question": "Array, Set, Dictionary의 차이점에 대해 설명해주세요",
    "answers": [
      "Array는 리스트 컬렉션으로 Random Access가 가능해 인덱스를 통해 요소에 접근할 수 있습니다.",
      "Set은 Hashable 프로토콜을 채택하는 값을 저장해 중복되지 않은 데이터를 관리하는 콜렉션입니다. 순서가 보장되지 않으며, 교집합, 차집합 등 집합 연산을 메서드로 제공합니다",
      "Dictionary 는 Key-Value 형태로 데이터를 관리하는 콜렉션입니다. 딕셔너리의 Key로 사용될 타입은 Hashable 프로토콜을 채택하고 중복된 키를 허용하지 않으며 순서를 보장하지 않습니다."
    ]
  },
  {
    "id": "ios-24",
    "question": "required 키워드에 대해서 설명해보세요.",
    "answers": [
      "required 키워드가 붙은 클래스의 생성자는 해당 클래스를 상속받는 자식 클래스가 해당 생성자를 반드시 구현하도록 강제합니다.",
      "required 에는 override 키워드의 기능이 포함되어 있기 때문에 override를 생략하고 구현할 수 있습니다."
    ]
  },
  {
    "id": "ios-25",
    "question": "Array보다 Set을 사용하는게 더 좋을 때는 언제일까요?",
    "answers": [
      "순서가 중요하지 않고 데이터를 중복없이 고유하게 관리할 때 Set을 사용하는 것이 더 좋습니",
      "특히, Set은 삭제, 삽입, 조회를 모두 O(1)에 할 수 있기 때문에 순서가 중요하지 않으면서 삭제와 삽입이 빈번할 때도 Set이 더 좋을 수 있습니다."
    ]
  },
  {
    "id": "ios-26",
    "question": "Trailing Closure에 대해서 설명해보세요. (What is trailing closure synta",
    "answers": [
      "함수의 인자로 들어갈 클로저를 함수 호출 외부로 분리해서 코드를 작성하는 방법입니다.",
      "trailing closure의 파라미터 레이블을 생략할 수 있고, 만약 호출하는 함수의 파라미터가 클로저 뿐이라면 () 도 생략할 수 있습니다."
    ]
  },
  {
    "id": "ios-27",
    "question": "@objc는 언제 사용하나요?",
    "answers": [
      "@objc 는 스위프트의 API를 Objective-C 런타임에 사용할 수 있도록 하기위해 사용합니다"
    ]
  },
  {
    "id": "ios-28",
    "question": "Defer에 대해 설명해보세요.",
    "answers": [
      "defer는 클로저에 정의된 코드가 읽어진 이후에 함수가 끝나기 전 마지막에 실행되도록 합니다."
    ]
  },
  {
    "id": "ios-29",
    "question": "fileprivate과 private의 차이를 설명해보세요.",
    "answers": [
      "fileprivate은 같은 파일 내부에 있다면 접근을 허용했지만 private은 같은 파일에 있어도 private으로 선언한 대상의 구현부 내부, 그리고 같은 파일에 있는 동일한 선언의 Extension 에서의 접근만 허용합니다."
    ]
  },
  {
    "id": "ios-30",
    "question": "open과 public 키워드의 차이를 설명해보세요",
    "answers": [
      "open과 public 키워드 모두 외부 모듈에서의 접근을 허용합니다. 그러나 open은 클래스에서만 사용할 수 있습니다. open 키워드를 사용하면 외부 모듈에서 해당 클래스를 상속하거나 메소드를 오버라이딩할 수 있지만, public 키워드를 사용한 경우에는 외부 모듈에서 클래스 상속과 메소드 오버라이딩을 제한합니다",
      "동일한 모듈 내에서는 open과 public 모두 클래스 상속과 메소드 오버라이딩이 가능합니다. 따라서 open은 클래스를 다른 모듈에서 확장하거나 수정할 수 있는 확장성을 제공하는 반면에, public은 외부 모듈에서의 접근을 허용하지만 클래스를 상속하거나 수정하는 것은 제한하는 데 사용됩니다."
    ]
  },
  {
    "id": "ios-31",
    "question": "Function과 Closure의 차이를 설명해보세요.",
    "answers": [
      "Function과 Closure 모두 실행가능한 코드블록을 의미합니다.",
      "Function은 func 키워드와 함께 선언되고 함수의 이름을 항상 가져야합니다. 반면에 클로저는 이름을 가지지 않습니다."
    ]
  },
  {
    "id": "ios-32",
    "question": "언제 클래스 대신 구조체를 사용하면 좋을까요?",
    "answers": [
      "스위프트에서는 기본적으로 구조체를 사용하길 권장하고 있습니다.",
      "구조체는 불변성을 유지하기 때문에 여러 스레드들이 한 인스턴스를 사용하는 다중 스레드 환경에서도 안전하게 사용될 수 있습니다.",
      "구조체는 스택에 저장하기 때문에 더 빠릅니다. 힙에 저장되는 클래스는 힙에 인스턴스를 저장하고 그 참조값을 스택에 저장합니다."
    ]
  },
  {
    "id": "ios-33",
    "question": "언제 구조체 대신 클래스를 선택해야할까요?",
    "answers": [
      "구조체는 값 타입이기 때문에 값이 같은 인스턴스가 매번 복사되어 사용됩니다.",
      "따라서 만약 어떤 인스턴스의 참조값의 고유성을 유지하고 싶다면 클래스를 사용할 수 있습니다.",
      "Objective-C의 API를 사용할 때는 클래스가 반드시 필요하기도 합니다. i.e.)NSCache의 value에는 구조체 인스턴스를 사용할 수 없습니다."
    ]
  },
  {
    "id": "ios-34",
    "question": "weak과 unowned 의 차이를 설명해주세요",
    "answers": [
      "weak은 참조하고 있던 인스턴스가 해제되는 것을 염두하여 항상 Optional한 타입을 가집니다. 만약 weak으로 선언한 변수가 참조하고 있던 인스턴스가 메모리에서 해제되면 해당 변수의 값은 nil로 채워집니다.",
      "unowned는 참조하고 있는 인스턴스가 unowned 변수 이전에는 절대 해제되지 않음을 보장하는 상황에서 사용합니다.",
      "unwoend는 Optional을 허용하지 않습니다. 따라서 unowned가 참조하고 있던 인스턴스가 해제된 이후에 unowned 변수를 참조하면 런타임 에러가 발생합니다."
    ]
  },
  {
    "id": "ios-35",
    "question": "unowned는 언제 사용하는 것이 안전할까요?",
    "answers": [
      "unowned로 선언된 변수가 참조하는 인스턴스가 해당 unowned 변수가 해제된 이후에 해제되는 것이 보장되는 상황에서 사용하는 것이 안전합니다."
    ]
  },
  {
    "id": "ios-36",
    "question": "Swift의 Copy-on-Write에 대해서 설명해보세요",
    "answers": [
      "Copy-on-Write는 값 타입의 복사를 실제로 값이 수정되기 전까지는 발생시키지 않아 메모리 사용을 최적화하는 방법입니다. 예를 들어서 값타입인 배열을 두 변수에 저장해두면 두 개의 다른 인스턴스가 생성될 것을 기대하지만 실제로는 주소 값을 공유하고 있다가 변수에 변경사항이 생겼을 때 새로운 인스턴스를 할당합니다",
      "수정이 일어나지 않는 값 타입 데이터는 복사본을 만들지 않고 사용되기 때문에 메모리 사용을 최적화할 수 있습니다."
    ]
  },
  {
    "id": "ios-37",
    "question": "Hashable 프로토콜에 대해서 설명해보세요.",
    "answers": [
      "Hashable 프로토콜을 채택하는 타입은 모두 값을 정수인 해시값으로 표현할 수 있습니다.",
      "스위프트의 기본 타입 중 문자열, 정수, 실수, 불리언, 그리고 Set 콜렉션이 Hashable 프로토콜을 채택하고 있습니다."
    ]
  },
  {
    "id": "ios-38",
    "question": "Hashable 프로토콜에 대해서 설명해보세요.",
    "answers": [
      "Hashable 프로토콜을 채택하는 타입은 모두 값을 정수인 해시값으로 표현할 수 있습니다.",
      "스위프트의 기본 타입 중 문자열, 정수, 실수, 불리언, 그리고 Set 콜렉션이 Hashable 프로토콜을 채택하고 있습니다."
    ]
  },
  {
    "id": "ios-39",
    "question": "옵셔널 체이닝(Optional Chaining)은 어떤 상황에서 사용하는 것이 가장 효과적인가요?",
    "answers": [
      "Swift의 옵셔널 체이닝은 주로 객체의 속성이나 메서드를 호출할 때 해당 객체가 옵셔널일 수 있는 경우에 사용됩니다. 이를 통해 객체가 nil인지 아닌지를 안전하게 확인하고, 객체가 nil인 경우에도 안전하게 작업을 수행할 수 있습니다."
    ]
  },
  {
    "id": "ios-40",
    "question": "UIKit에서 UIWindow 객체의 역할은 무엇인가요?",
    "answers": [
      "UIWindow는 UIView의 하위 클래스로, 앱의 배경과 이벤트를 처리하는 무대 역할을 합니다. 실제로 화면에 보이는 내용은 아니지만, 앱의 뷰 계층 구조를 관리하고 rootViewController에서 관리하는 주요 뷰를 표시하는 기본 컨테이너로 작동합니다."
    ]
  }
]
